ifdef::env-github[]
:toc:
:sectnums:
:sectnumlevels: 1
:sectanchors: 

== Annotations, pragmas and doc comments
endif::[]

As explained before Blech allows annotations to declarations. 
In principle every declaration can have one or more annotations.

Currently we use annotations for the entry point of a Blech program and for the binding to C implementations.

[source, blech]
----
@[EntryPoint]
activity ... end

@[CConst(binding="A_C_CONST")]
extern const ABlechConst
----

C bindings have an optional header parameter where the necessary header file can be defined.

In order to prevent repetition we also allow pragmas which are annotations to the current scope. 
Pragmas can occur where members or statements are allowed.
Pragmas are similar to annotations but start with `@@`.

Currently we use pragmas for central C include file definitions in order to prevent repitition of header definitions in annotations.

[source, blech]
----
@@[CInclude(header="myheader.h")]

@[CConst(binding="A_C_CONST")]
extern const ABlechConst

@[CConst(binding="ANOTHER_C_CONST")]
extern const AnotherBlechConst
----

Pragmas can be used in order to define metadata for a whole compilation unit or to give directives to the compiler - valid to the scope where they occur.
Imagine the following - which is currently not implemented.

[source, blech]
----
@@[Link(lib="myclib.a")]

function f(x: int32)
    if x > 10 then
        @@[AllowShadowing]
        var x: float32
        x = 42.0
    end
end
----

Annotations also allow to attach doc comments to the abstract syntax tree.
Line doc comments and block doc comments are stored as annotations.

[source, blech]
----
/// a line doc comment
const myConst = 11

/** 
    a block doc comment
*/
function myDocumentedFunc()
end
----

Parsed doc comments allow to reproduce documentation in `.blh` signature files and in generated code.
