ifdef::env-github[]
:toc:
:sectnums:
:sectnumlevels: 1
:sectanchors: 

== Calling into the Blech environment
endif::[]

=== External C functions

External C functions are either pure functions or functions with side-effects.
Pure functions do not change the environment.
Functions with side-effects change the environment via global variables, not visible in the function prototype.

External C functions are classified by the keyword `extern`.
If the function already exists, an annotation defining the binding to this C function can be added: `@[CFunction ...]`.

If the external C function is a pure function with no hidden side effects it follows the synchronous semantics and allows for correct causality analysis.

If the external C function is a function with side-effects on global variables in the environment, it does not follow the synchronous semantics.
From the prototype of this function the read-write access to these global variables is not visible.
As a consequence, causality analysis cannot prevent calling this function from concurrent trails.
This means, the single-writer principle on global variables in the environment cannot be maintained.

[source, blech]
----
@[CFunction(binding="")]
extern function noSideEffect()

@[CFunction(binding="")]
extern function hasSideEffect() // writes to a global variable

activity multipleWriters()
    cobegin
        noSideEffect()
        await true
        hasSideEffect()
    with
        await true
        hasSideEffect()
    end
end
----

Here the function `hasSideEffect` is called from two concurrent trails.
The effect on the global variable is not predictable and depends on the order in which both calls are scheduled by the code generation.


=== External functions with side-effects are singletons

In order two prevent concurrent writes on global variables in the environment it needs more effort by the programmer.
An external C function with side effects should be declared as a `singleton`.


[source, blech]
----
@[CFunction(binding="")]
extern function noSideEffect()

@[CFunction(binding="")]
extern singleton function hasSideEffect() // writes to a global variable

activity multipleWriters()
    cobegin
        noSideEffect()
        await true
        hasSideEffect()
    with
        await true
        hasSideEffect() // causality error
    end
end
----

`hasSideEffects` being a `singleton` makes the above program causally incorrect.
A correct program restricts calling `hasSideEffects` to one trail.

[source, blech]
----
activity singleWriter()
    cobegin
        noSideEffect()
        await true
        hasSideEffect()
    with
        await true
        noSideEffect()
    end
end
----

WARNING: It is the responsibility of the programmer to declare external C functions that write to global variables as `singleton`.

=== Callers become singletons too

The signature for this 3 subprograms looks like the following

[source, blech]
----

function noSideEffect()
singleton function hasSideEffect() // reads and write a global variable

singleton hasSideEffect
activity singleWriter()
----

Since `activity` singleWriter calls a singleton it becomes a `singleton` too.
The singleton property is deduced by the compiler, there is no need to declare `singleWriter` as a singleton.

The same is true for function that calls a singleton function.

=== Correct protocols become singletons too

Although the singleton property only maintains the single-writer principle it is also usefull for more complex protocols.

Assume the following interface functions for accessing an SPI interface

[source, blech]
----
@[CFunction(binding = "NRF24L01_spiXferBytes", header = "nrf24l01.h")]
extern singleton function SPI_XferBytes (txBuf: [SPI_TX_BUF]uint8, len: uint16) 
                                        (rxBuf: [SPI_TX_BUF]uint8) 
                                        returns int8

@[CFunction(binding = "NRF24L01_spiIsReady", header = "nrf24l01.h")]
extern singleton function SPI_isReady () returns bool

@[CFunction(binding = "NRF24L01_beginTransfer", header = "nrf24l01.h")]
extern singleton function SPI_beginTransfer ()

@[CFunction(binding = "NRF24L01_endTransfer", header = "nrf24l01.h")]
extern singleton function SPI_endTransfer ()
----

Functions which change the environment are declared as `singleton` in order to make sure that they are not called from concurrent trails.

Function `SPI_isReady` is read-only but should also be declared as a `singleton`.
The reason is that two calls to `SPI_isReady` could have different results because the underlying flag in the environment is changed asynchronously. 

Without declaring `SPI_isReady` as a singleton the following code can have unpredictable results

[source, blech]
----
cobegin
    await SPI_isReady()
    ...
with 
    await SPI_isReady()
    ...
end
----

Within the same reaction, one trail might wait, while the other might go on.
Being a `singleton` concurrent calls would not be allowed, an the above code would be rejected by the compiler.

IMPORTANT: External functions that might return a different result in every call should be declared as `singleton`. 
Typically this is necessary when the result depends on `volatile` or asynchronously changed data.

The `activity` transfering bytes via SPI, can be written as follows.

[source, blech]
----
activity SPI_txRxBytes (bufTx: [SPI_TX_BUF]uint8, len: uint16)
                       (bufRx: [SPI_TX_BUF]uint8) 
                       returns int8
    // SPI ready for TX?
    if not SPI_isReady() then
        await SPI_isReady()
    end

    // Trigger asynchronous byte transfer via SPI.
    if SPI_XferBytes (bufTx, bufRx, len) != 0 then
        return -1
    end

    // Await completion.
    await SPI_isReady()
    return 0
end
----

This activity is a singleton because it calls singleton functions.

Of coures it is possible to call, for example, two singleton functions concurrently.

[source, blech]
----
    cobegin
        SPI_beginTransfer()
        await true
    with
        SPIEndTransfer()
        await true
    end
----

This has unpredictable effects in the environment.
In this case the programmer did not follow the correct protocol for usage of the SPI interface.

If we follow the protocol, activity `SPI_txRxBytes` can be called inside a transaction that submits a command to an RF hardware using SPI.

[source, blech]
----
activity RF_sendCmdWord (cmd: uint8, dataTx: [SPI_TX_BUF]uint8, len: uint8)
                        (dataRx: [SPI_TX_BUF]uint8) 
                        returns int8
    SPI_beginTransfer()

    var res: int8

    // Send command.
    var tmp: [SPI_TX_BUF]uint8 = {cmd} // we have to allocate a big buffer for ONE byte!
    res = run SPI_txRxBytes(tmp, 1)(dataRx)

    if res == 0 then
        // Send data.
        res = run SPI_txRxBytes(dataTx, len)(dataRx)
    end

    SPI_endTransfer()

    return res
end
----

Again `RF_sendCmdWord` is a singleton.

Now, this activity cannot be called concurrently to one of the SPI interface functions.
The compiler would reject the following code

[source, blech]
----
    cobegin
        _ = run RF_sendCmd(RF_CMD_NOP, dataTx, 0)(dataRx)
    with
        SPI_endTransfer() 
        await true
    end
----

This code is completely stupid according to the SPI protocol but is prevented from occuring in a Blech program.

The deduced signature for those subprograms looks as follows.

[source, blech]
----
singleton function SPI_XferBytes (txBuf: [SPI_TX_BUF]uint8, len: uint16)  
                                 (rxBuf: [SPI_TX_BUF]uint8) 
                                 returns int8

singleton function SPI_isReady () returns bool

singleton function SPI_beginTransfer ()

singleton function SPI_endTransfer ()

singleton SPI_XferBytes
activity SPI_txRxBytes (bufTx: [SPI_TX_BUF]uint8, len: uint16)
                       (bufRx: [SPI_TX_BUF]uint8) 
                       returns int8

singleton SPI_beginTransfer, SPI_XferBytes, SPI_endTransfer
activity RF_sendCmdWord (cmd: uint8, dataTx: [SPI_TX_BUF]uint8, len: uint8)
                        (dataRx: [SPI_TX_BUF]uint8) 
                        returns int8
----

IMPORTANT: Calls to singletons cause sourrounding code to be singleton too.
This works up to the `@[EntryPoint]` activity, which naturally is a singleton.
This is not a bug in Blech but a consequence of the use of global variables.
Restricting the use of global variables to the environment enables the programmer to keep the pure application code free from singletons, which is much better than todays practice to use global variables everywhere.

