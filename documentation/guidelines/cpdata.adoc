ifdef::env-github[]
:toc:
:sectnums:
:sectnumlevels: 1
:sectanchors: 

== Translating Blech variable names to C
endif::[]

=== Possibilities in Blech

Variable names appear in different *syntactic* contexts (expressions):

 . current / previous access
 . lhs / rhs value (in assignment)
 . lhs / rhs reference (in procedure call)

Variable names appear in different *declaration* contexts:

 . Parameter input / output
 . Global constant
 . Activity- / function-local Blech variable
 . Activity-local external C-variable
 . Auxiliary variable introduced by the compiler

Variable names may represent various kinds of data *types*:
 
 . Simple (atomic)
 . Structures
 . Arrays

Not all combinations are possible.
Below is an overview of what is possible in Blech and what the corresponding generated C code must look like.

=== Possibilities in generated C code
Blech constants will be either substituted by their names or translated to a macro or a static `const` declaration on the top level of the C code.
_Note: Blech-procedure-local constants may well be translated to C-function-local static const variables._
Bottom line: there is a static name by which the value can be accessed.
The name is used as-is or with referencing `&` (when passing a struct as an input argument). Dereferencing is not need as we do not have constants that point anywhere (so long as there are no `ref` in Blech).

Everything else will be one of the following:
 
 . Formal parameter of a function
 . Function local (`auto`) variable
 . Wrapped inside the context structure `blc_blech_ctx` (which itself is passed as a function argument)

Case 1 is used as is or with dereferencing `*`. +
Case 2 is used as is or with referencing `&`. +
_Note: There is no * on auto variables because as of now we do not have `ref` in Blech, thus a variable is never a pointer to something unless it is passed in as a function argument. (Case 1)_ +
Case 3 we can have both

 - blc_blech_ctx-><identifier> which is the same as (*blc_blech_ctx).<identifier>
 - &(blc_blech_ctx-><identifier>) which is the same as &((*blc_blech_ctx).<identifier>)


=== Previous access
 - Can only be read => restriction to rhs in assignment, input argument in procedure call
 - `prev` can only be applied to activity-local variables
[IMPORTANT]
TODO: check if `prev` is allowed on constants/params global/local. Which way do we want it?
 - prev'ed activity local variables may be internal (Blech) or external variables
 - all types of data may be prev'ed

The following relationship between source and generated code is established

.Blech -> C translation
[cols="2*",grid=rows]
|===
| Blech | C

| prev of activity-local *Blech variable* | automatic variable inside C-function, initialised at reaction start using the corresponding current value
| prev of activity-local *external variable* | extra cell in `blc_blech_ctx`, named `blc_prev_<variable identifier>`, set at the end of the reaction using the corresponding current value
|===

Thus in the first case, the access follows the same logic as an auto name access.
In the second case, the access follows the same logic as a context element.
See below for details.

=== Current access
All accesses to Blech variables boil down to one of the cases from the following table.

.C accesses
[cols="5*",grid=rows]
|===
| Case | as-is | `*`, `->` | `&` | `&(*...)`, `&(->)`
| 1. static name | ✓ | - | ✓ | -
| 2. parameter name | ✓ | ✓ | - | ✓
| 3. local (auto) name | ✓ | - | ✓ | -
| 4. context element | - | ✓ | - | ✓
|===

Any kind of Blech constant param -> case 1. +
Blech procedure parameter -> case 2. +
Function local variable -> case 3. +
Activity local variable -> case 4. +
Activity local external variable -> case 3. +
(Prev activity variable -> case 3.) +
(Prev external variable -> case 4.)

Once a case / row has been determined, it is up to the usage context and data type that determines how exactly to access the data.

=== 2nd try

Translating any access to data runs through several stages:

Given a typed memory location `foo[0].bar`... +
_(Remark: `prev foo[0].bar` binds as `(prev foo)[0].bar`)._

 . For the QNamePrefix part `foo`, determine a name scheme (depending on declaration context)
 .. Static name `blc_<longId>_foo` or `blc_<moduleName>_<longId>_foo`
 .. Parameter name `blc_foo`
 .. Auto name `blc_foo`
 .. Context element `blc_blech_ctx->blc_foo`
 .. Auxiliary name `aux_blc_foo`
 .. prev of Blech var `prev_blc_foo`
 .. prev of extern var `blc_blech_ctx->prev_blc_foo`
 . Ensure the name `<name>` generated above represents the memory blob itself, not a pointer to it
 .. if `foo` is a simple type or struct parameter rewrite name from above to `*<name>` +
 Nothing to do for arrays as the name (pointer to the first element) already _represents_ the whole array blob.
 . Append all field / cell access to this name `<name>[0].bar`
 . Depending on usage context and type (of `bar`) determine whether to use the path as is or construct a reference from it

.Usage context and type
[cols="4*",grid=rows]
|===
|  | simple | struct | array 
| lhs assign | as-is | as-is | as-is
| rhs assign | as-is | as-is | as-is 
| output arg | & | & | as-is 
| input arg | as-is | & | as-is 
|===

Possibly reduce trivial combinations like `&(*<name>)` to `<name>`. This will happen for e.g. simple typed output parameters passed on as an output argument.

=== Remarks and after thoughts:
The `blc_` prefix is used to make sure we never overwrite global variables with the same name (that might appear in C sources outside the scope of the generated Blech code). Of course, we assume that the `blc_` prefix is reserved and not used by sources not generated by the Blech compiler.

However previous variables use the scheme `prev_blc_` making `prev_` yet another exclusive prefix. We cannot simply generate `blc_prev_<id>` for `prev <id>` as this would clash with a regular Blech variable called `prev_id`.

We also use `blc_` for naming fields in the activity context. This ensure we rule out clashes between normal and prev'ed external variables in the activity context.

Auxiliary variables use yet another prefix `aux_blc_`.
This ensures they do not shadow a global C variable with the same name (assuming that the environment never uses names starting with `aux_blc_`).
This is basically the same reasoning as with auto variables. However we need the extra `aux_` to prevent a clash with an actual Blech variable.

[IMPORTANT]
TODO: at the moment all constants and params in local scopes are lifted to the top level.
Why do we not use the `static` keyword of C and let the declaration remain inside the function?