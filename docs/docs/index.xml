<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Blech â€“ Documentation</title>
    <link>https://boschresearch.github.io/blech-doc/docs/</link>
    <description>Recent content in Documentation on Blech</description>
    <generator>Hugo -- gohugo.io</generator>
    
	  <atom:link href="https://boschresearch.github.io/blech-doc/docs/index.xml" rel="self" type="application/rss+xml" />
    
    
      
        
      
    
    
    <item>
      <title>Docs: Expressions, conditions, initialisers, constants</title>
      <link>https://boschresearch.github.io/blech-doc/docs/blechc-development/const-and-expr/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://boschresearch.github.io/blech-doc/docs/blechc-development/const-and-expr/</guid>
      <description>
        
        
        &lt;h2 id=&#34;equality-expressions&#34;&gt;Equality expressions&lt;/h2&gt;
&lt;p&gt;Theoretically, every type supports some notion of equality (and inequality).
This is straightforward for &lt;strong&gt;simple (or primitive) value types&lt;/strong&gt; that consist of one memory cell only (booleans and all numeric types of all sizes):
&lt;code&gt;a == b&lt;/code&gt; holds iff the value of &lt;code&gt;a&lt;/code&gt; is the same as the value of &lt;code&gt;b&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;For &lt;strong&gt;structured (complex) value types&lt;/strong&gt; we can decide equality by comparing every element of data structures recursively.
At compile time the result of a comparison can be evaluated if the arguments are compile time constants.
Thus it is technically no problem to compare compile time constants of any value type.&lt;/p&gt;
&lt;p&gt;At runtime a recursive comparison algorithm is too much of a runtime penalty and what looks like a constant time operation turns out to be growing with the dimension of the structure.
An optimisation of runtime - not changing the run-time complexity but providing better factors - could be achieved by comparing the data structures byte-wise (&lt;code&gt;memcmp&lt;/code&gt;).
But this requires to fix padding in structs and then fails in special cases:
floating point elements may use different bit representations for the same numerical value, e.g. &lt;code&gt;+0.0&lt;/code&gt; and &lt;code&gt;-0.0&lt;/code&gt;.
Consequently, the comparison operator for structured data may not be used at runtime (like in C) and results in a type check error.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Reference types are not implemented yet but in principle they will have the same behaviour: compare (dereferenced) values for simple types, and disallow comparison for complex types.&lt;/em&gt;&lt;/p&gt;
&lt;h2 id=&#34;using-constants&#34;&gt;Using constants&lt;/h2&gt;
&lt;p&gt;In order to make evaluation work for arbitrary constant expressions the names are resolved by the constant values (literals) they represent.
Thus at the end of the type check phase the declarations of the consts do exist and can be translated to C but all their usages disappear (being substituted by the value).
This has the drawback of less readable C code but still allows to export constants as #defines and use them in foreign code by including the relevant &lt;code&gt;.h&lt;/code&gt; file.&lt;/p&gt;
&lt;p&gt;In C89, structs can be initialised using structured literals but cannot be assigned new values using structured literals.
The same is true for arrays in all versions of C.
Additionally, when calling functions the arguments need to be pointers to memory locations that contain the (structured) data.
In all these cases, in the generated C code we create a stack local (automatic) temporary variable that is initialised using the literal and then use that variable (or its address) to perform assignments or function calls.
In summary, literals occur only on the right hand side of initialisation in the generated C code.&lt;/p&gt;
&lt;h2 id=&#34;side-effects-in-conditions-are-not-allowed&#34;&gt;Side effects in conditions are not allowed&lt;/h2&gt;
&lt;p&gt;It is obvious that testing an &lt;code&gt;await&lt;/code&gt; condition may not have any impact on the state to implement a synchronous program.
Additionally, we forbid side effects in conditions of preemption and all standard, imperative statements.
This clearly seperates concerns of making decision about the current program state and (possibly) triggering other, (possibly) concurrent computation.
The common programming practice of C where conditions&amp;rsquo; side effects are used to also advance computation is regarded as bad practice in Blech until proven otherwise.&lt;/p&gt;
&lt;h2 id=&#34;side-effects-are-allowed-in-initialisers&#34;&gt;Side effects are allowed in initialisers&lt;/h2&gt;
&lt;p&gt;Despite the urge to restrict the wild programmer, we allow side effects when declaring and initialising a variable.
Otherwise the following code that declares an immutable variable cannot be written:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;let status = f()(x)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Instead, we would have to write&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;var status: typeOfF
status = f()(x)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;which not only is longer and less readable but makes &lt;code&gt;status&lt;/code&gt; a mutable variable which is not the intention of the programmer.&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: Model of execution</title>
      <link>https://boschresearch.github.io/blech-doc/docs/user-manual/controlflow/moc/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://boschresearch.github.io/blech-doc/docs/user-manual/controlflow/moc/</guid>
      <description>
        
        
        &lt;h2 id=&#34;reactive-execution&#34;&gt;Reactive execution&lt;/h2&gt;
&lt;p&gt;Unlike classical desktop applications that solve a given task, a Blech application does not run in isolation by itself.
It interacts with a so-called &lt;em&gt;environment&lt;/em&gt; that triggers a &lt;em&gt;reaction&lt;/em&gt; of the Blech program.&lt;/p&gt;
&lt;p&gt;Typically, the environment provides a set of &lt;em&gt;inputs&lt;/em&gt; to a Blech program. These inputs may, for example, be sensor readings.
The environment then expects the Blech program to perform some computations and finally return a set of updated &lt;em&gt;outputs&lt;/em&gt;.
Outputs can be interpreted by the environment, for example, as set points for actuators.&lt;/p&gt;
&lt;p&gt;We deliberately use the generic word &amp;ldquo;environment&amp;rdquo; because depending on the use case it may have a different form.
It ranges from just a loop that calls the Blech application as soon as the last reaction has finished to a sophisticated real-time operating system which manages several tasks, timers and event queues.&lt;/p&gt;
&lt;p&gt;The Blech program maintains its state from one reaction to the next.
Thus a reaction does not merely depend on the given inputs but also on the state of the program itself.&lt;/p&gt;
&lt;h2 id=&#34;synchrony&#34;&gt;Synchrony&lt;/h2&gt;
&lt;p&gt;Blech is a &lt;em&gt;synchronous&lt;/em&gt; language.
That means its semantics adhere to the &amp;ldquo;synchrony assumption&amp;rdquo;.
In simple terms it states that a reaction happens instantaneously (takes no physical time).
Thus program execution proceeds in discrete reactions and there is no observable behaviour in between.&lt;/p&gt;
&lt;p&gt;This is of course not implementable in reality but rather a guideline for semantics that has implications on language design and induces a set of crucial properties that make the programmer&amp;rsquo;s life easier.&lt;/p&gt;
&lt;p&gt;One implication is that inputs keep their value throughout the reaction. This prevents a volatile behaviour where two readings of the same variable in the same reaction may produce two different values.&lt;/p&gt;
&lt;p&gt;The other implication  is that concurrent computations adhere to a &lt;a href=&#34;https://en.wikipedia.org/wiki/Consistency_model#Strict_consistency&#34; target=&#34;_blank&#34;&gt;strict consistency&lt;/a&gt;
 notion.
In essence, this means that &amp;ldquo;a write to a variable by any thread needs to be seen instantaneously by all threads [&amp;hellip;] it assumes concurrent writes to be impossible&amp;rdquo;.
Therefore race conditions are excluded by design.
Since each concurrent thread of execution perceives the others as instantaneous, every shared variable must assume precisely one value throughout the reaction.
It must not be possible for a reader to read two different values for a shared variable within one reaction.
This would discern computation into (at least two) different logical time steps and violate the assumption that the computation happened instantaneously.&lt;/p&gt;
&lt;p&gt;This semantics is very attractive to the programmer because concurrent programming becomes simple to understand and debug.
It is the single most crucial distinctive feature of synchronous programming languages in general, and Blech in particular.
Usually in asynchronous, thread-based programming this strict consistency notion is impossible to achieve in practice.
However strict consistency becomes possible in our setting because of two ingredients usually not present in asynchronous concurrent programming:
the distinction of individual reactions; and the distinction of a thread-local view and a global view on a shared memory.&lt;/p&gt;
&lt;p&gt;Synchronous languages differ in what programs they admit such that strict consistency is guaranteed.
Such programs are called causally correct or simply &lt;em&gt;causal&lt;/em&gt;.
The next section explains what this means for Blech.&lt;/p&gt;
&lt;h2 id=&#34;causality&#34;&gt;Causality&lt;/h2&gt;
&lt;p&gt;The strict consistency memory model excludes write conflicts by definition.
Since we think of program execution as reaction steps, this means causal programs must have at most one writer per shared variable in one reaction.
In Blech we restrict this even further and require that there is at most one writer within a fork-join scope which is potentially executed for multiple reactions.
This is made more precise in the subsequent chapter when we explain the &lt;code&gt;cobegin&lt;/code&gt; statement.&lt;/p&gt;
&lt;p&gt;Furthermore, there is a &amp;ldquo;thread-local&amp;rdquo; view of shared variables and a &amp;ldquo;thread-global&amp;rdquo; view.
We require that in the thread-global view every shared variable is set to one value by the writer that all other threads may read.
However the writer-thread may update (and read) the variable multiple times locally.
Thus multiple values exist in the thread-local view but they are not observable by concurrent threads nor by the environment and the &amp;ldquo;illusion&amp;rdquo; of instantaneous updates is maintained.
Only the last written value is communicated to the concurrent readers.
Of course, &amp;ldquo;last&amp;rdquo; is to be understood with respect to the current reaction.
In essence, for every variable there is a write-before-read policy in every reaction.
This allows for normal sequential imperative programming within a thread and at the same time leverages the expressiveness and simplicity of synchronous concurrent programming.
Note that this deliberately excludes programs where threads are mutually (cyclically) dependent within a reaction.&lt;/p&gt;


&lt;div class=&#34;alert alert-warning&#34; role=&#34;alert&#34;&gt;

There is at most one writer per shared variable. The writer must finish its last writing operation to a shared variable in the current reaction before concurrent readers may read it.
&lt;/div&gt;

&lt;p&gt;The compiler phase that statically ensures a given Blech program is causal is called &lt;em&gt;causality analysis&lt;/em&gt;.&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: Notation</title>
      <link>https://boschresearch.github.io/blech-doc/docs/user-manual/notation/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://boschresearch.github.io/blech-doc/docs/user-manual/notation/</guid>
      <description>
        
        
        &lt;p&gt;We use a modified Backus-Naur form notation to describe the Blech language syntax.
The modifications to the original BNF make the rules look more like regular expressions.
We follow the same notation conventions as the &lt;a href=&#34;https://docs.python.org/3/reference/index.html&#34; target=&#34;_blank&#34;&gt;Python language documentation&lt;/a&gt;
. Here is what they write about notation:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The descriptions of lexical analysis and syntax use a modified BNF grammar notation. This uses the following style of definition:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-abnf&#34; data-lang=&#34;abnf&#34;&gt;&lt;span style=&#34;color:#000&#34;&gt;name&lt;/span&gt;      ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;  lc_&lt;span style=&#34;color:#000&#34;&gt;letter&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;lc_&lt;span style=&#34;color:#000&#34;&gt;letter&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;_&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;*&lt;/span&gt;
lc_&lt;span style=&#34;color:#000&#34;&gt;letter&lt;/span&gt; ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;  &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;a&amp;#34;&lt;/span&gt;...&lt;span style=&#34;color:#000&#34;&gt;&amp;#34;z&amp;#34;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The first line says that a &lt;code&gt;name&lt;/code&gt; is an &lt;code&gt;lc_letter&lt;/code&gt; followed by a sequence of zero or more &lt;code&gt;lc_letter&lt;/code&gt;s and underscores. An &lt;code&gt;lc_letter&lt;/code&gt; in turn is any of the single characters &lt;code&gt;&#39;a&#39;&lt;/code&gt; through &lt;code&gt;&#39;z&#39;&lt;/code&gt;. (This rule is actually adhered to for the names defined in lexical and grammar rules in this document.)&lt;/p&gt;
&lt;p&gt;Each rule begins with a name (which is the name defined by the rule) and &lt;code&gt;::=&lt;/code&gt;. A vertical bar (&lt;code&gt;|&lt;/code&gt;) is used to separate alternatives; it is the least binding operator in this notation. A star (&lt;code&gt;*&lt;/code&gt;) means zero or more repetitions of the preceding item; likewise, a plus (&lt;code&gt;+&lt;/code&gt;) means one or more repetitions, and a phrase enclosed in square brackets (&lt;code&gt;[ ]&lt;/code&gt;) means zero or one occurrences (in other words, the enclosed phrase is optional). The &lt;code&gt;+*+&lt;/code&gt; and &lt;code&gt;+&lt;/code&gt; operators bind as tightly as possible; parentheses are used for grouping. Literal strings are enclosed in quotes. White space is only meaningful to separate tokens. Rules are normally contained on a single line; rules with many alternatives may be formatted alternatively with each line after the first beginning with a vertical bar.&lt;/p&gt;
&lt;p&gt;In lexical definitions (as the example above), two more conventions are used: Two literal characters separated by three dots mean a choice of any single character in the given (inclusive) range of ASCII characters. A phrase between angular brackets (&lt;code&gt;+&amp;lt;...&amp;gt;+&lt;/code&gt;) gives an informal description of the symbol defined; e.g., this could be used to describe the notion of â€˜control characterâ€™ if needed.&lt;/p&gt;
&lt;/blockquote&gt;

      </description>
    </item>
    
    <item>
      <title>About: Privacy policy</title>
      <link>https://boschresearch.github.io/blech-doc/about/privacy/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://boschresearch.github.io/blech-doc/about/privacy/</guid>
      <description>
        
        
        

&lt;div class=&#34;pageinfo pageinfo-primary&#34;&gt;
&lt;p&gt;All content of this page is preliminary&lt;/p&gt;

&lt;/div&gt;

&lt;p&gt;This website does &lt;strong&gt;not&lt;/strong&gt; collect data or use cookies &lt;strong&gt;by default&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;In order to improve the content and the experience on the website we kindly ask you to allow the usage of site analytics. If you opt-in to this service we use cookies to collect anonymous usage data.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;You can learn about cookies and site analytics at &lt;a href=&#34;https://www.cookiechoices.org/&#34; target=&#34;_blank&#34;&gt;&lt;a href=&#34;http://www.cookiechoices.org&#34;&gt;www.cookiechoices.org&lt;/a&gt;&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;opt-in-for-google-analytics&#34;&gt;Opt-in for Google Analytics&lt;/h2&gt;
&lt;p&gt;You can opt-in for site analytics, in this opt-in notice&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://boschresearch.github.io/blech-doc/images/opt-in-notice.png&#34; alt=&#34;Opt-in notice&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;If you &lt;code&gt;Opt-in&lt;/code&gt; we use site analytics to collect your anonymous usage data.&lt;/li&gt;
&lt;li&gt;If you close &lt;code&gt;x&lt;/code&gt; this notice, no data will be collected.&lt;/li&gt;
&lt;li&gt;We use a cookie to remember your decision.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;After your opt-in we use &lt;a href=&#34;https://marketingplatform.google.com/about/analytics/features/&#34; target=&#34;_blank&#34;&gt;Google Analytics&lt;/a&gt;
 tracking on
this website, which uses cookies for this purpose.&lt;/p&gt;
&lt;p&gt;We are interested in understanding&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;what pages you visited and for how long,&lt;/li&gt;
&lt;li&gt;what site referred you to this web page,&lt;/li&gt;
&lt;li&gt;what types of content and topic areas you are interested in,&lt;/li&gt;
&lt;li&gt;including what content or sections never get viewed or used.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Your IP-Adress is anonymized, so we do &lt;strong&gt;not&lt;/strong&gt; store wether you have been to the site before.&lt;/p&gt;
&lt;h2 id=&#34;do-not-track&#34;&gt;Do not track&lt;/h2&gt;
&lt;p&gt;We respect your &lt;a href=&#34;https://en.wikipedia.org/wiki/Do_Not_Track&#34; target=&#34;_blank&#34;&gt;Do-Not-Track&lt;/a&gt;
 settings if your browser requests this.&lt;/p&gt;
&lt;p&gt;This means, you will never see the above opt-in notice, if you configured your browser for Do-Not-Track.
No cookies will be set. Google Analytics will not be used.&lt;/p&gt;
&lt;h2 id=&#34;hosting&#34;&gt;Hosting&lt;/h2&gt;
&lt;p&gt;This website is hosted by GitHub Pages. When you access the website, GitHub collects logging and usage data.
See the &lt;a href=&#34;https://help.github.com/en/github/site-policy/github-privacy-statement&#34; target=&#34;_blank&#34;&gt;GitHub Privacy Statement&lt;/a&gt;
 for details.&lt;/p&gt;
&lt;h2 id=&#34;linked-services&#34;&gt;Linked services&lt;/h2&gt;
&lt;p&gt;This website contains links to other services. If you follow these links you should become aware of their terms of service.&lt;/p&gt;
&lt;p&gt;We link to:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://help.github.com/en/github/site-policy/github-terms-of-service&#34; target=&#34;_blank&#34;&gt;GitHub&lt;/a&gt;
 for documentation, compiler and tools repositories.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://policies.google.com/terms&#34; target=&#34;_blank&#34;&gt;Google Groups&lt;/a&gt;
 for Blech user questions.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://slack.com/terms-of-service&#34; target=&#34;_blank&#34;&gt;Slack&lt;/a&gt;
 for Blech developer discussions.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://twitter.com/tos&#34; target=&#34;_blank&#34;&gt;Twitter&lt;/a&gt;
 for announcements.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Additional links might occur in the documentation and the blog posts.&lt;/p&gt;
&lt;h2 id=&#34;manage-cookies&#34;&gt;Manage cookies&lt;/h2&gt;
&lt;p&gt;You can manually delete and restrict the use of cookies in your web browser.&lt;/p&gt;
&lt;p&gt;Learn how to manage cookies for:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://support.apple.com/guide/safari/manage-cookies-and-website-data-sfri11471/mac&#34; target=&#34;_blank&#34;&gt;Apple Safari&lt;/a&gt;
&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://support.google.com/chrome/bin/answer.py?hl=en-GB&amp;amp;answer=95647&amp;amp;p=cpn_cookies&#34; target=&#34;_blank&#34;&gt;Google Chrome&lt;/a&gt;
&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://support.microsoft.com/help/4027947/microsoft-edge-delete-cookies&#34; target=&#34;_blank&#34;&gt;Microsoft Edge&lt;/a&gt;
&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://support.microsoft.com/help/17442/windows-internet-explorer-delete-manage-cookies&#34; target=&#34;_blank&#34;&gt;Microsoft Internet Explorer&lt;/a&gt;
&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://support.mozilla.org/products/firefox/protect-your-privacy/cookies&#34; target=&#34;_blank&#34;&gt;Mozilla Firefox&lt;/a&gt;
&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: Borrowing</title>
      <link>https://boschresearch.github.io/blech-doc/docs/language-evolution/borrowing/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://boschresearch.github.io/blech-doc/docs/language-evolution/borrowing/</guid>
      <description>
        
        
        &lt;h2 id=&#34;borrowing-in-rust-and-blech&#34;&gt;Borrowing in Rust and Blech&lt;/h2&gt;
&lt;p&gt;Blech&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;function outIsInPlus1 (a: int32)(b: int32)
    b = 1
    b = a + b 
end

activity main()
    var i = 42: int32
    incr(i)(i) // --&amp;gt; 43
    await true
end
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;A similar program in Rust.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;outIsInPlus1&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;a&lt;/span&gt;: &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;i32&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;b&lt;/span&gt;: &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;mut&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;i32&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;{&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;    &lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;b&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;a&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;main&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;()&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;{}&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;    &lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;let&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;mut&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;i&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;42&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;    &lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;outIsInPlus1&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;i&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;mut&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;i&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;);&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;    &lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;println&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;!&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;{}&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;i&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;);&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;  &lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;// --&amp;gt; 43
&lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;No problem with this. Because the input parameter &lt;code&gt;a&lt;/code&gt; has value/copy semantics.&lt;/p&gt;
&lt;p&gt;Blech automatically takes references and de-references them if necessary. It decides on mutability through the occurence in the input or output parameter list. Semantically the Blech program has the following form:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;function outIsInPlus1(&amp;lt;let&amp;gt; a: int32)(&amp;lt;var ref&amp;gt; b: int32)
    &amp;lt;*&amp;gt; b = 1
    &amp;lt;*&amp;gt; b = &amp;lt;*&amp;gt; a + &amp;lt;*&amp;gt; b 
end

activity main()
    var i = 42: int32
    outIsInPlus1(i)(&amp;lt;&amp;amp;&amp;gt; i) // --&amp;gt; 43
    await true
end
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This is semantically very close to Rust.&lt;/p&gt;
&lt;p&gt;We would change the function in Blech if the input &lt;code&gt;a&lt;/code&gt; should be passed by reference.
Note that references are not implemented in the current compiler.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;function outIsInPlus1(ref a: int32)(b: int32)
    b = 1       // b = 1
    b = a + b   // b = 1 + a
end

activity main()
    var i = 42: int32
    outIsInPlus1(i)(i) // --&amp;gt; 2
    await true
end
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The value of output &lt;code&gt;i&lt;/code&gt; becomes &lt;code&gt;2&lt;/code&gt;, which is not input &lt;code&gt;i&lt;/code&gt; plus &lt;code&gt;1&lt;/code&gt;. For functions in Blech this could be allowed, because they do not contain &lt;code&gt;cobegin&lt;/code&gt;, but it is dangerous and unexpected, especially at the caller side, where you can&amp;rsquo;t see this behaviour by reading the code.&lt;/p&gt;
&lt;p&gt;Rust does not allow this call. The borrow checker detects an error.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;outIsInPlus1&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;a&lt;/span&gt;: &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;i32&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;b&lt;/span&gt;: &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;mut&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;i32&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;{&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;    &lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;b&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;    &lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;b&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;a&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;b&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;main&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;()&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;{&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;    &lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;let&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;mut&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;i&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;42&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;    &lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;outIsInPlus1&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;i&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;mut&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;i&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;);&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-txt&#34; data-lang=&#34;txt&#34;&gt;error[E0502]: cannot borrow `i` as mutable because it is also borrowed as immutable
 --&amp;gt; src/example.rs:9:11
  |
9 |     outIsInPlus1(&amp;amp;i, &amp;amp;mut i);
  |     ------------ --  ^^^^^^ mutable borrow occurs here
  |     |            |
  |     |            immutable borrow occurs here
  |     immutable borrow later used by call

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;This behavior is similar to the use of parameters in Blech activities. Blech does not allow the following &lt;code&gt;run outIsInPlus1(i)(i)&lt;/code&gt; statement. The causality checker detects an error.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;activity outIsInPlus1(a: int32)(b: int32)
    b = 1       // b = 1
    b = a + b   // b = 1 + a
    await true
end

activity main()
    var i = 42: int32
    run outIsInPlus1(i)(i)
    await true
end
&lt;/code&gt;&lt;/pre&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-txt&#34; data-lang=&#34;txt&#34;&gt;error: Read-write conflict. i or an alias thereof occurs both in the input and output list of the sub program call.
  --&amp;gt; example.blc:11:5 [causality]

11 |     run outIsInPlus1(i)(i)
   |                         - Output argument.
11 |     run outIsInPlus1(i)(i)
   |                      ^ Input argument.

  If this usage is intended, consider using the &amp;#34;shares&amp;#34; keyword when declaring the formal parameters of the subprogram.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Blech automatically takes refencences and de-references if necessary. It decides on mutability through the occurence in the input or output parameter list. Input parameters in Blech are semantically passed by-value for functions and passed by-reference for activities.
Therefore the activity &lt;code&gt;outIsInPlus1&lt;/code&gt; has semantically the following form:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;activity outIsInPlus1(&amp;lt;let ref&amp;gt; a: int32)(&amp;lt;var ref&amp;gt;b: int32)
    &amp;lt;*&amp;gt; b = 1       
    &amp;lt;*&amp;gt; b = &amp;lt;*&amp;gt; a + &amp;lt;*&amp;gt; b
    await true
end

activity main()
    var i = 42: int32
    run outIsInPlus1(&amp;lt;&amp;amp;&amp;gt; i)(&amp;lt;&amp;amp; mut&amp;gt; i)
    await true
end
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Actually the above causality error is almost equivalent to Rust&amp;rsquo;s borrowing error.&lt;/p&gt;
&lt;p&gt;We would argue, that the above function with an input parameter passed by-reference should be marked as an error if called with identical references.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;function outIsInPlus1(ref a: int32)(b: int32)
...
    var i = 42: int32
    outIsInPlus1(i)(i)  // causality error or borrowing error
...
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;If we have more uses for borrowing and a &lt;strong&gt;borrowing checker&lt;/strong&gt; this could become a &lt;strong&gt;borrowing error&lt;/strong&gt; instead of a causality error.&lt;/p&gt;
&lt;h2 id=&#34;borrowing&#34;&gt;Borrowing&lt;/h2&gt;
&lt;p&gt;Passing parameters by-reference is essentially borrowing a reference.&lt;/p&gt;
&lt;p&gt;There are several combinations&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Blech&lt;/th&gt;
&lt;th&gt;Semantics&lt;/th&gt;
&lt;th&gt;Blech call&lt;/th&gt;
&lt;th&gt;Call semantics&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;function f (a: T)&lt;/td&gt;
&lt;td&gt;function f (let a: T)&lt;/td&gt;
&lt;td&gt;f(x)&lt;/td&gt;
&lt;td&gt;f(x)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;function f (ref a: T)&lt;/td&gt;
&lt;td&gt;function f (let ref a: T)&lt;/td&gt;
&lt;td&gt;f(x)&lt;/td&gt;
&lt;td&gt;f(&amp;amp;x)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;function f ()(b: T)&lt;/td&gt;
&lt;td&gt;function f ()(var ref b: T)&lt;/td&gt;
&lt;td&gt;f()(x)&lt;/td&gt;
&lt;td&gt;f()(&amp;amp;x)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;activity a (a: T)&lt;/td&gt;
&lt;td&gt;activity a (let ref a: T)&lt;/td&gt;
&lt;td&gt;run a(x)&lt;/td&gt;
&lt;td&gt;run a(&amp;amp;x)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;activity a ()(b: T)&lt;/td&gt;
&lt;td&gt;activity a ()(var ref b: T)&lt;/td&gt;
&lt;td&gt;run a()(x)&lt;/td&gt;
&lt;td&gt;run a()(&amp;amp;x)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;In case of an input parameter it is a non-mutable borrowing. In case of an output parameter it a mutable borrowing.&lt;/p&gt;
&lt;h2 id=&#34;borrowing-via-reference-declarations&#34;&gt;Borrowing via reference declarations&lt;/h2&gt;
&lt;p&gt;Borrowing not only occurs when passing parameters, but also when declaring references.
We also planned this for Blech.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;activity main()
    var x: int32 = 42
    let ref y = x
    x = y + 1 // x == 43, y == 43 
    await true
end
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This would be a strange behaviour in Blech, when reasoning about this program. Especially since &lt;code&gt;y&lt;/code&gt; is a read-only reference, but changes its value via the assignment. Rust forbids this by the borrow checker.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;main&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;()&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;{&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;    &lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;let&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;mut&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;x&lt;/span&gt;: &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;i32&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;42&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;    &lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;let&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;y&lt;/span&gt;: &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;i32&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;x&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;    &lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;x&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;y&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;    &lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;println&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;!&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;x:{}, y:{}&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;x&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;y&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;);&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-txt&#34; data-lang=&#34;txt&#34;&gt;error[E0506]: cannot assign to `x` because it is borrowed
 --&amp;gt; src/main.rs:4:5
  |
3 |     let y: &amp;amp;i32 = &amp;amp;x;
  |                   -- borrow of `x` occurs here
4 |     x = *y + 1;
  |     ^^^^^^^^^^ assignment to borrowed `x` occurs here
5 |     println!(&amp;#34;x:{}, y:{}&amp;#34;, x, y);
  |                               - borrow later used here
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;In Rust you cannot use &lt;code&gt;x&lt;/code&gt; after it has been non-mutably borrowed to &lt;code&gt;y&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;We propose to adopt the ideas of borrowing from Rust to Blech, in order to benefit from the guarantees the borrow checker gives for your program.&lt;/p&gt;
&lt;h2 id=&#34;behaviour-of-the-borrow-checker&#34;&gt;Behaviour of the borrow checker&lt;/h2&gt;
&lt;p&gt;A good overview of how borrowing restricts the usage of variables and references can be found in a &lt;a href=&#34;https://rufflewind.com/2017-02-15/rust-move-copy-borrow#comments&#34; target=&#34;_blank&#34;&gt;Graphical depiction of ownership and borrowing in Rust&lt;/a&gt;
.&lt;/p&gt;
&lt;p&gt;Move semantics can be neglected for the moment since currently only have value types which all allow copying, which in Rust terminology means, they implement the copy trait. Nevertheless move semantics might become important in for Blech&amp;rsquo;s planned reference types.&lt;/p&gt;
&lt;p&gt;For borrowing it distinguishes between &lt;em&gt;frozen&lt;/em&gt; and &lt;em&gt;locked&lt;/em&gt; behaviour.&lt;/p&gt;
&lt;p&gt;Mutable borrowing, &lt;em&gt;locks&lt;/em&gt; the original object for the duration of the borrow, rendering it unusable.&lt;/p&gt;
&lt;p&gt;Non-mutable borrowing &lt;em&gt;freezes&lt;/em&gt; the original object, you can still take more non-mutable references, but you cannot move or take mutable references of it.&lt;/p&gt;
&lt;h3 id=&#34;non-mutable-borrow-freezes-original-object&#34;&gt;Non-mutable borrow &lt;em&gt;freezes&lt;/em&gt; original object&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;activity main()
    var s: int32 = 42
    do
        let ref r = s  // ok, s is now frozen
        cobegin
            // can non-mutably borrow from r 
            let ref a = r  // ok 
            ...
        with
            // can still &amp;amp;s
            let ref b = s  // ok
            ...
        with
            // cannot &amp;amp;mut s
            var ref c = s // not ok, similar to first example, could read s via r, and write s via c
            ...
        with
            // cannot move s
            // not applicable because s has a value type
            ...
        end
    end
    // all borrows terminated    
    s = s + 1 
    await true
end
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;mutable-borrow-locks-original-object&#34;&gt;Mutable borrow &lt;em&gt;locks&lt;/em&gt; original object&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;activity main()
    var s: int32 = 42
    do
        var ref m = s  // ok, s is locked
        cobegin 
            // can move m
            var ref a = move m // ok, cannot use m anymore, will be discussed later
            ...
        with
            // can downgrade m to read-only
            let ref b = m  // ok, m is now frozen
            ...
        with
            // can borrow mutably from m
            var ref c = m  // ok, m is locked from here
        with
            // cannot copy m
            // not applicable, references are taken and de-referenced implicitly
            ...
        with
            // cannot use s at all, s is locked
            let ref d = s  // not ok
            var ref e = s  // not ok
            let e = s      // not ok
            var e = s      // not ok
            ...
        end
    end
    // all borrows terminated    
    s = s + 1 
    await true
end
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;As shown before, passing parameters can be explained as borrowing&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Passing a parameter to an output list essentially is a borrowing as mutable reference.&lt;/li&gt;
&lt;li&gt;Passing an input parameter in an activity essentially is borrowing as a non-mutable reference.&lt;/li&gt;
&lt;li&gt;Passing an input parameter to a function is copying.&lt;/li&gt;
&lt;li&gt;Passing an input parameter to a formal reference parameter is borrowing.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;As shown here, taking references in various forms can also be explained as borrowing.&lt;/p&gt;
&lt;p&gt;Borrowing has a sequential ordering along the program text.
This could be used to enable multiple concurrent writers for specific memory cells.&lt;/p&gt;
&lt;h2 id=&#34;borrowing-for-sequential-parallel-writes&#34;&gt;Borrowing for sequential parallel writes&lt;/h2&gt;
&lt;p&gt;The merely theorectical &amp;ldquo;sequential-parallel-or&amp;rdquo; operator is dangerous, because it switches off causality analysis completely, for all accesses to memory cells.&lt;/p&gt;
&lt;p&gt;Therefore we propose to enable sequential parallel writes for indivual memory locations.
We could use the sequential ordering of borrowing for this.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;...
    var original: int32
    cobegin
        run controlValue()(original)
    with
        var ref updated = original // mutable borrow
        run updateValue()(updated)
    end
    ...
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;What is the semantics?&lt;/p&gt;
&lt;p&gt;In every step the activity &lt;code&gt;controlValue&lt;/code&gt; writes to &lt;code&gt;original&lt;/code&gt;. We can understand borrowing as a sequential chaining. In every step of the second thread &lt;code&gt;updated&lt;/code&gt; borrows &lt;code&gt;original&lt;/code&gt;, which in turn is updated in every step. &lt;code&gt;original&lt;/code&gt; is locked here and cannot be used. The borrowing defines a sequential write order.&lt;br&gt;
We can regard both blocks of the &lt;code&gt;cobegin&lt;/code&gt; as partially sequentialised.&lt;/p&gt;
&lt;p&gt;Of course we can switch the blocks with the same semantics.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;...
    var original: int32
    cobegin
        var ref updated = original // mutable borrow, original is locked
        run updateValue()(updated)
    with
        run controlValue()(original)
    end
    ...
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The borrowing &lt;code&gt;var ref update = original&lt;/code&gt; defines an &amp;ldquo;update &lt;code&gt;original&lt;/code&gt; from &lt;code&gt;updated&lt;/code&gt; edge&amp;rdquo; for causality analysis. Every writeable location must not have more than 1 incoming update edge.&lt;/p&gt;
&lt;p&gt;Without references and borrowing we need local variables to sequentialise the write accesses in &lt;code&gt;controlValue&lt;/code&gt; and &lt;code&gt;updateValue&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;...
    var original: int32
    var local: int32
    var updated = original
    cobegin
        run controlValue(prev updated)(local)
    with
        run updateValue(local)(updated)
    with 
        repeat
            original = updated
            await true
        end
    end
    ...
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This solution, which is perfectly correct in the current compiler, is adopted from the &lt;a href=&#34;https://github.com/frameworklabs/blinker/blob/master/src/blinker.blc&#34; target=&#34;_blank&#34;&gt;Blech blinker example&lt;/a&gt;
.&lt;/p&gt;
&lt;p&gt;Compared to the first version the second needs 2 additional memory locations, additional parameters to enable the data flow, a loop that copies the result back to &lt;code&gt;original&lt;/code&gt; in every step, and additionally &lt;code&gt;controlValue&lt;/code&gt; and &lt;code&gt;updateValue&lt;/code&gt; need to copy from input to output in every step. As usual the order of &lt;code&gt;cobegin&lt;/code&gt; blocks is irrelevant.&lt;/p&gt;
&lt;p&gt;The version with references and borrowing can reuse the &lt;code&gt;original&lt;/code&gt; memory location based on the statically defined sequential order and needs no additional copying loops.&lt;/p&gt;
&lt;p&gt;Now, what happens if both threads borrow &lt;code&gt;original&lt;/code&gt;?&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;...
    var original: int32
    cobegin
        var ref controlled = original // mutable borrow
        run controlValue()(original)
    with
        var ref updated = original    // mutable borrow
        run updateValue()(updated)
    end
    ...
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The location &lt;code&gt;original&lt;/code&gt; has now 2 incoming update edges from &lt;code&gt;controlled&lt;/code&gt; and &lt;code&gt;updated&lt;/code&gt; which is essentially a write-write conflict in causality analysis.&lt;/p&gt;
&lt;p&gt;The &amp;lsquo;trick&amp;rsquo; of the sequentialisation is scoping of borrowing. If we need 3 concurrent threads that write to the &lt;code&gt;original&lt;/code&gt; memory location, we need to scope borrowing, which nicely shows the sequentialisation.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;...
    var original: int32
    cobegin 
        run initialiseValue()(original)
    with
        var ref controlled = original // mutable borrow
        cobegin
            run controlValue()(controlled)
        with
            var ref updated = controlled // mutable borrow
            run updateValue()(updated)
        end
    end
    ...
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;We have update egdes from  &lt;code&gt;updated&lt;/code&gt; to &lt;code&gt;controlled&lt;/code&gt; and from &lt;code&gt;controlled&lt;/code&gt; to &lt;code&gt;original&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;To make things more interesting we can mix-in causal concurrency.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;...
    var original: int32
    var a: int32
    var b: int32
    cobegin
        run controlValue(a)(b, original)
    with
        var ref updated = original
        run updateValue(b)(a, updated)
    end
    ...
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Here we get a cyclic write-read path on &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;. We can use &lt;code&gt;prev&lt;/code&gt; to break this cycle. Since &lt;code&gt;original&lt;/code&gt; must be written before &lt;code&gt;updated&lt;/code&gt;, this only helps if we apply &lt;code&gt;prev&lt;/code&gt; to the input of activity &lt;code&gt;controlValue&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;...
    var original: int32
    var a: int32
    var b: int32
    cobegin
        run controlValue(prev a)(b, original)
    with
        var ref updated = original // mutable borrowing
        run updateValue(b)(a, updated)
    end
    ...
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Note: Non-mutable borrowing does not imply additional causal constraints. It is simply write before read. But it helps clarifying the program semantics as explained in the introduction.&lt;/p&gt;
&lt;h2 id=&#34;dismiss-shares&#34;&gt;Dismiss &lt;code&gt;shares&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;Blech currently proposes to use a &lt;code&gt;shares&lt;/code&gt; if this an intended behaviour.
We think this is no longer necessary with borrowing, causality and passing inputs to functions by-reference and by-value.&lt;/p&gt;
&lt;h2 id=&#34;todo&#34;&gt;Todo&lt;/h2&gt;
&lt;h3 id=&#34;borrow-spitting&#34;&gt;Borrow spitting&lt;/h3&gt;
&lt;p&gt;[Spitting borrows]https://doc.rust-lang.org/nomicon/borrow-splitting.html&lt;/p&gt;
&lt;p&gt;Similar to splitting causality analysis. Ok for structs, not possible for arrays.&lt;/p&gt;
&lt;p&gt;Rules for borrow checker like in Rust.&lt;/p&gt;
&lt;h3 id=&#34;the-move-operator&#34;&gt;The &lt;code&gt;move&lt;/code&gt; operator&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://stackoverflow.com/questions/30288782/what-are-move-semantics-in-rust&#34; target=&#34;_blank&#34;&gt;What are move semantics in Rust?&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;Move should be handled and clarified separately. It is related to reference types.&lt;/p&gt;
&lt;h3 id=&#34;splitting-borrows-and-partial-moves&#34;&gt;Splitting borrows and partial moves&lt;/h3&gt;

      </description>
    </item>
    
    <item>
      <title>About: Contact information</title>
      <link>https://boschresearch.github.io/blech-doc/about/contact/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://boschresearch.github.io/blech-doc/about/contact/</guid>
      <description>
        
        
        

&lt;div class=&#34;pageinfo pageinfo-primary&#34;&gt;
&lt;p&gt;All content of this page is preliminary&lt;/p&gt;

&lt;/div&gt;

&lt;h2 id=&#34;name-and-address&#34;&gt;Name and address&lt;/h2&gt;
&lt;p&gt;Robert Bosch GmbH &lt;br&gt;
Robert-Bosch-Platz 1 &lt;br&gt;
70839 Gerlingen-SchillerhÃ¶he &lt;br&gt;
GERMANY&lt;/p&gt;
&lt;h2 id=&#34;members-of-the-board-of-management&#34;&gt;Members of the Board of Management&lt;/h2&gt;
&lt;p&gt;Dr. Volkmar Denner, Prof. Dr. Stefan Asenkerschbaumer, Dr. Michael Bolle, Dr. Christian Fischer, Dr. Stefan Hartung, Dr. Markus Heyn, Harald KrÃ¶ger, Christoph KÃ¼bel, Rolf Najork, Uwe Raschke, Peter Tyroller&lt;/p&gt;
&lt;h2 id=&#34;your-contact-at-bosch-research&#34;&gt;Your contact at Bosch research&lt;/h2&gt;
&lt;p&gt;&lt;i class=&#34;fas fa-envelope&#34;&gt;&lt;/i&gt; &lt;a href=&#34;mailto:opensource@bosch.com&#34;&gt;&lt;a href=&#34;mailto:opensource@bosch.com&#34;&gt;opensource@bosch.com&lt;/a&gt;&lt;/a&gt;
 &lt;br&gt;
&lt;i class=&#34;fas fa-link&#34;&gt;&lt;/i&gt; &lt;a href=&#34;https://www.bosch.com/research&#34; target=&#34;_blank&#34;&gt;&lt;a href=&#34;http://www.bosch.com/research&#34;&gt;www.bosch.com/research&lt;/a&gt;&lt;/a&gt;
&lt;/p&gt;
&lt;h2 id=&#34;register-entries&#34;&gt;Register Entries&lt;/h2&gt;
&lt;p&gt;Registration Court: District Court Stuttgart HRB 14000&lt;/p&gt;
&lt;h2 id=&#34;value-added-tax-identification-number&#34;&gt;Value-added tax identification number&lt;/h2&gt;
&lt;p&gt;DE811128135&lt;/p&gt;
&lt;h2 id=&#34;responsible&#34;&gt;Responsible&lt;/h2&gt;
&lt;p&gt;Robert Bosch GmbH &lt;br&gt;
Corporate Research &lt;br&gt;
Dr. Carsten Tschamber &lt;br&gt;
Robert-Bosch-Campus 1&lt;br&gt;
71272 Renningen &lt;br&gt;
GERMANY&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: Lexical elements</title>
      <link>https://boschresearch.github.io/blech-doc/docs/user-manual/lexical/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://boschresearch.github.io/blech-doc/docs/user-manual/lexical/</guid>
      <description>
        
        
        &lt;h2 id=&#34;comments&#34;&gt;Comments&lt;/h2&gt;
&lt;p&gt;Single line comments are C++ style. They begin with &lt;code&gt;//&lt;/code&gt; and end with the end of line.&lt;/p&gt;
&lt;p&gt;Multi-line comments are C style. They begin with &lt;code&gt;/*&lt;/code&gt; and end with &lt;code&gt;*/&lt;/code&gt;.
Comment nesting is supported.&lt;/p&gt;
&lt;h3 id=&#34;declaration-comments&#34;&gt;Declaration Comments&lt;/h3&gt;
&lt;p&gt;A special comment syntax allows to write comments for declarations (functions, activities, types, variables, &amp;hellip;) which will be transported over to the generated C code.
This allows to document the API and make this documentation available to the C programmer who integrates generated code in a larger scope.&lt;/p&gt;
&lt;p&gt;There are two supported styles of declaration comments.
Java style multi-line comments &lt;code&gt;/** */&lt;/code&gt; and .Net style single line comments &lt;code&gt;///&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Note that using declaration comments before something that is not a declaration, e.g. an assignment, is a syntax error.&lt;/p&gt;
&lt;h2 id=&#34;built-in-operators-and-separators&#34;&gt;Built-in Operators and Separators&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Operators and Separators&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Logical operators&lt;/td&gt;
&lt;td&gt;&lt;code&gt;not&lt;/code&gt; &lt;code&gt;and&lt;/code&gt; &lt;code&gt;or&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Arithmetic operators&lt;/td&gt;
&lt;td&gt;&lt;code&gt;+&lt;/code&gt; &lt;code&gt;-&lt;/code&gt; &lt;code&gt;*&lt;/code&gt; &lt;code&gt;/&lt;/code&gt; &lt;code&gt;%&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Bitwise operators&lt;/td&gt;
&lt;td&gt;&lt;code&gt;~&lt;/code&gt; &lt;code&gt;&amp;amp;&lt;/code&gt; &lt;code&gt;|&lt;/code&gt; &lt;code&gt;^&lt;/code&gt; &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Relational operators&lt;/td&gt;
&lt;td&gt;&lt;code&gt;==&lt;/code&gt; &lt;code&gt;!=&lt;/code&gt; &lt;code&gt;&amp;lt;&lt;/code&gt; &lt;code&gt;&amp;gt;&lt;/code&gt; &lt;code&gt;&amp;lt;=&lt;/code&gt; &lt;code&gt;&amp;gt;=&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Type conversion&lt;/td&gt;
&lt;td&gt;&lt;code&gt;as&lt;/code&gt; &lt;code&gt;as!&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Separators&lt;/td&gt;
&lt;td&gt;&lt;code&gt;(&lt;/code&gt; &lt;code&gt;)&lt;/code&gt; &lt;code&gt;[&lt;/code&gt; &lt;code&gt;]&lt;/code&gt; &lt;code&gt;{&lt;/code&gt; &lt;code&gt;}&lt;/code&gt; &lt;code&gt;.&lt;/code&gt; &lt;code&gt;,&lt;/code&gt; &lt;code&gt;;&lt;/code&gt; &lt;code&gt;:&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;keywords&#34;&gt;Keywords&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;abort&lt;/code&gt;
&lt;code&gt;activity&lt;/code&gt;
&lt;code&gt;and&lt;/code&gt;
&lt;code&gt;as&lt;/code&gt;
&lt;code&gt;await&lt;/code&gt;
&lt;code&gt;bits8&lt;/code&gt;
&lt;code&gt;bits16&lt;/code&gt;
&lt;code&gt;bits32&lt;/code&gt;
&lt;code&gt;bits64&lt;/code&gt;
&lt;code&gt;blech&lt;/code&gt;
&lt;code&gt;bool&lt;/code&gt;
&lt;code&gt;cobegin&lt;/code&gt;
&lt;code&gt;const&lt;/code&gt;
&lt;code&gt;do&lt;/code&gt;
&lt;code&gt;else&lt;/code&gt;
&lt;code&gt;elseif&lt;/code&gt;
&lt;code&gt;end&lt;/code&gt;
&lt;code&gt;extern&lt;/code&gt;
&lt;code&gt;false&lt;/code&gt;
&lt;code&gt;float32&lt;/code&gt;
&lt;code&gt;float64&lt;/code&gt;
&lt;code&gt;function&lt;/code&gt;
&lt;code&gt;if&lt;/code&gt;
&lt;code&gt;int8&lt;/code&gt;
&lt;code&gt;int16&lt;/code&gt;
&lt;code&gt;int32&lt;/code&gt;
&lt;code&gt;int64&lt;/code&gt;
&lt;code&gt;let&lt;/code&gt;
&lt;code&gt;nat8&lt;/code&gt;
&lt;code&gt;nat16&lt;/code&gt;
&lt;code&gt;nat32&lt;/code&gt;
&lt;code&gt;nat64&lt;/code&gt;
&lt;code&gt;not&lt;/code&gt;
&lt;code&gt;or&lt;/code&gt;
&lt;code&gt;param&lt;/code&gt;
&lt;code&gt;prev&lt;/code&gt;
&lt;code&gt;repeat&lt;/code&gt;
&lt;code&gt;run&lt;/code&gt;
&lt;code&gt;reset&lt;/code&gt;
&lt;code&gt;return&lt;/code&gt;
&lt;code&gt;returns&lt;/code&gt;
&lt;code&gt;singleton&lt;/code&gt;
&lt;code&gt;struct&lt;/code&gt;
&lt;code&gt;then&lt;/code&gt;
&lt;code&gt;true&lt;/code&gt;
&lt;code&gt;until&lt;/code&gt;
&lt;code&gt;var&lt;/code&gt;
&lt;code&gt;weak&lt;/code&gt;
&lt;code&gt;when&lt;/code&gt;
&lt;code&gt;while&lt;/code&gt;
&lt;code&gt;with&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Note that the current compiler implementation may reserve more keywords than listed here.
This is because the language is still growing and there are concepts that are yet to be fully implemented but already exist on the syntactical level.&lt;/p&gt;
&lt;h2 id=&#34;identifiers&#34;&gt;Identifiers&lt;/h2&gt;
&lt;p&gt;An identifier is any token that is not a keyword and starts with a letter or underscore and continues with an arbitrary number of letters, digits or underscores.
The precise definition is given by the following grammar rule&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-abnf&#34; data-lang=&#34;abnf&#34;&gt;&lt;span style=&#34;color:#000&#34;&gt;Identifier&lt;/span&gt; ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;  &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;_&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;&amp;#34;a&amp;#34;&lt;/span&gt;...&lt;span style=&#34;color:#000&#34;&gt;&amp;#34;z&amp;#34;&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;A&amp;#34;&lt;/span&gt;...&lt;span style=&#34;color:#000&#34;&gt;&amp;#34;Z&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;+ &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;&amp;#34;_&amp;#34;&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;a&amp;#34;&lt;/span&gt;...&lt;span style=&#34;color:#000&#34;&gt;&amp;#34;z&amp;#34;&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;A&amp;#34;&lt;/span&gt;...&lt;span style=&#34;color:#000&#34;&gt;&amp;#34;Z&amp;#34;&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;0&amp;#34;&lt;/span&gt;...&lt;span style=&#34;color:#000&#34;&gt;&amp;#34;9&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;*&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Note that identifiers have an infix of at least one letter.&lt;/p&gt;
&lt;h2 id=&#34;wildcard&#34;&gt;Wildcard&lt;/h2&gt;
&lt;p&gt;Additionally we reserve a token that consists of underscores only.
We call this the &amp;ldquo;wildcard&amp;rdquo;. Wildcards are useful when you want to discard the result of a computation without declaring a dummy variable.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;_ = f()
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;In this example you cannot just call &lt;code&gt;f&lt;/code&gt; like in C because the Blech compiler will complain that &lt;code&gt;f&lt;/code&gt; is declared to return a value but there is no location to store this value in. The wildcard makes the intention to discard the returned value &lt;em&gt;explicit&lt;/em&gt;.&lt;/p&gt;
&lt;h2 id=&#34;literals&#34;&gt;Literals&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-abnf&#34; data-lang=&#34;abnf&#34;&gt;&lt;span style=&#34;color:#000&#34;&gt;BoolLiteral&lt;/span&gt; ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;true&amp;#34;&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;false&amp;#34;&lt;/span&gt;

&lt;span style=&#34;color:#000&#34;&gt;Digit&lt;/span&gt;        ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;0&amp;#34;&lt;/span&gt;...&lt;span style=&#34;color:#000&#34;&gt;&amp;#34;9&amp;#34;&lt;/span&gt;
&lt;span style=&#34;color:#000&#34;&gt;NonZeroDigit&lt;/span&gt; ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;1&amp;#34;&lt;/span&gt;...&lt;span style=&#34;color:#000&#34;&gt;&amp;#34;9&amp;#34;&lt;/span&gt;

&lt;span style=&#34;color:#000&#34;&gt;BinInteger&lt;/span&gt; ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;0b&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;&amp;#34;_&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;0&amp;#34;&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;1&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;+
&lt;span style=&#34;color:#000&#34;&gt;OctInteger&lt;/span&gt; ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;0o&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;&amp;#34;_&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;0&amp;#34;&lt;/span&gt;...&lt;span style=&#34;color:#000&#34;&gt;&amp;#34;7&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;+
&lt;span style=&#34;color:#000&#34;&gt;HexInteger&lt;/span&gt; ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;0x&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;&amp;#34;_&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;0&amp;#34;&lt;/span&gt;...&lt;span style=&#34;color:#000&#34;&gt;&amp;#34;7&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;&amp;#34;_&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;Digit&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;a&amp;#34;&lt;/span&gt;...&lt;span style=&#34;color:#000&#34;&gt;&amp;#34;f&amp;#34;&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;A&amp;#34;&lt;/span&gt;...&lt;span style=&#34;color:#000&#34;&gt;&amp;#34;F&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;+  
&lt;span style=&#34;color:#000&#34;&gt;DecInteger&lt;/span&gt; ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;NonZeroDigit&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;([&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;&amp;#34;_&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Digit&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;*&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;0&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;([&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;&amp;#34;_&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;0&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;*&lt;/span&gt;

&lt;span style=&#34;color:#000&#34;&gt;Integer&lt;/span&gt; ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;DecInteger&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;BinInteger&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;OctInteger&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;HexInteger&lt;/span&gt;

&lt;span style=&#34;color:#000&#34;&gt;FloatNumber&lt;/span&gt;   ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;  &lt;span style=&#34;color:#000&#34;&gt;PointFloat&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;ExponentFloat&lt;/span&gt;
&lt;span style=&#34;color:#000&#34;&gt;PointFloat&lt;/span&gt;    ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;  &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;DigitPart&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Fraction&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;DigitPart&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;.&amp;#34;&lt;/span&gt;
&lt;span style=&#34;color:#000&#34;&gt;DigitPart&lt;/span&gt;     ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;  &lt;span style=&#34;color:#000&#34;&gt;Digit&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;([&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;&amp;#34;_&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Digit&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;*&lt;/span&gt;
&lt;span style=&#34;color:#000&#34;&gt;Fraction&lt;/span&gt;      ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;  &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;.&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;DigitPart&lt;/span&gt;
&lt;span style=&#34;color:#000&#34;&gt;ExponentFloat&lt;/span&gt; ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;  &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;DigitPart&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;PointFloat&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;exponent&lt;/span&gt;
&lt;span style=&#34;color:#000&#34;&gt;Exponent&lt;/span&gt;      ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;  &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;&amp;#34;e&amp;#34;&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;E&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;&amp;#34;+&amp;#34;&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;-&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;DigitPart&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
      </description>
    </item>
    
    <item>
      <title>Docs: Statements</title>
      <link>https://boschresearch.github.io/blech-doc/docs/user-manual/controlflow/statements/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://boschresearch.github.io/blech-doc/docs/user-manual/controlflow/statements/</guid>
      <description>
        
        
        &lt;p&gt;In its core, Blech is an imperative language.
Blech strictly separates between &lt;em&gt;statements&lt;/em&gt; that govern the flow of control and &lt;em&gt;expressions&lt;/em&gt; that evaluate to a value.
Both, a statement and an expression may have side-effects.&lt;/p&gt;
&lt;h2 id=&#34;activities-and-functions&#34;&gt;Activities and functions&lt;/h2&gt;
&lt;p&gt;Control flow is organised with two kinds of procedures: &lt;em&gt;activities&lt;/em&gt; and &lt;em&gt;functions&lt;/em&gt;.
Functions are used like in any other imperative language.
In Blech they have two parameter lists to support causality analysis.&lt;/p&gt;


&lt;div class=&#34;alert alert-primary&#34; role=&#34;alert&#34;&gt;
&lt;h4 class=&#34;alert-heading&#34;&gt;TODO&lt;/h4&gt;
See the section on &amp;laquo;decl:subprogs,subprogram declarations&amp;raquo; for more details.
&lt;/div&gt;

&lt;p&gt;Functions must terminate within a reaction. Therefore they are said to be instantaneous.&lt;/p&gt;
&lt;p&gt;Activities are called similarly to functions but their execution continues until it reaches a pause to end the current reaction.
In the next reaction they resume from the location they have paused and continue execution until the next pause.
Each reaction of an activity must end after finitely many computation steps.
However the activity itself may perform an unbounded number of reactions and never terminate.
It may also terminate after a finite number of reactions.
In nay case, activities must not be instantaneous&amp;ndash;they need to pause at least once before termination.
The values of local variables in activities are kept from one reaction to the next.&lt;/p&gt;
&lt;p&gt;Activities may call other activities or functions.
Functions however can only call other functions.&lt;/p&gt;
&lt;h2 id=&#34;synchronous-statements&#34;&gt;Synchronous statements&lt;/h2&gt;
&lt;p&gt;Here we discuss statements that are specific to the synchronous paradigm of Blech.
These statements control the reactive behaviour of the program and hence may only appear inside activities, not in functions.&lt;/p&gt;
&lt;h3 id=&#34;await&#34;&gt;Await&lt;/h3&gt;
&lt;p&gt;The aforementioned &amp;ldquo;pause&amp;rdquo; is denoted as follows.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-abnf&#34; data-lang=&#34;abnf&#34;&gt;&lt;span style=&#34;color:#000&#34;&gt;Pause&lt;/span&gt; ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;await&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Condition&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The &lt;code&gt;await&lt;/code&gt; statement marks the end of a reaction.
The control flow stops at this statement and the program &amp;ldquo;waits&amp;rdquo; for the next reaction to start.
Once an activity resumes its execution at an &lt;code&gt;await&lt;/code&gt; statement the condition is checked.
If it is true, the control flow proceeds to the next statement.
Otherwise, the reaction ends immediately and the control flow remains at the same location.&lt;/p&gt;
&lt;h4 id=&#34;example-simple-reactive-control-flow&#34;&gt;Example: Simple reactive control flow&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;
&lt;table style=&#34;border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;&#34;&gt;&lt;tr&gt;&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;&#34;&gt;
&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;1
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;2
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;3
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;4
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;5
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;6
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;;width:100%&#34;&gt;
&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-txt&#34; data-lang=&#34;txt&#34;&gt;activity MyAct (in1: bool, in2: float32) (out1: uint8)
    repeat
        await in1
        out1 = (out1 + 1) % 100 // count from 0 to 99
    until in2 &amp;lt; 0.0 end
end
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;Initially, &lt;code&gt;MyAct&lt;/code&gt; is entered and the control flow proceeds to line 3 and stops (regardless of the inputs).
In the next tick, &lt;code&gt;MyAct&lt;/code&gt; resumes its execution at the &lt;code&gt;await&lt;/code&gt; statement in line 3.
It checks the boolean input variable &lt;code&gt;in1&lt;/code&gt;.
If it is false, the reaction ends immediately, the control flow does not advance.
Otherwise, if &lt;code&gt;in1&lt;/code&gt; is true, the calculation is carried out in line 4.
This updates &lt;code&gt;out1&lt;/code&gt; to a new value.
Finally, if input &lt;code&gt;in2&lt;/code&gt; is indeed less than 0 the activity terminates its execution.
Otherwise the control flow loops around from line 5 back to line 2 and finally the reaction ends again in line 3.&lt;/p&gt;
&lt;h3 id=&#34;run&#34;&gt;Run&lt;/h3&gt;
&lt;p&gt;An activity call is given by the following grammar.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-abnf&#34; data-lang=&#34;abnf&#34;&gt;&lt;span style=&#34;color:#000&#34;&gt;ActivityCall&lt;/span&gt; ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;Identifier&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;Wildcard&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;=&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;run&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Identifier&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;RhsArgList&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;LhsArgList&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;]&lt;/span&gt;
&lt;span style=&#34;color:#000&#34;&gt;RhsArgList&lt;/span&gt; ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;()&amp;#34;&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;(&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;RhsExpr&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;&amp;#34;,&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;RhsExpr&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;)&amp;#34;&lt;/span&gt;
&lt;span style=&#34;color:#000&#34;&gt;LhsArgList&lt;/span&gt; ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;()&amp;#34;&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;(&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;LhsExpr&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;&amp;#34;,&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;LhsExpr&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;)&amp;#34;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The &lt;code&gt;run&lt;/code&gt; keyword indicates an activity call.
Arguments must be provided that match the callee&amp;rsquo;s declaration in number and type.
If the callee does not declare any outputs the second pair of parentheses may be dropped for readability.
Input arguments must evaluate to a value that matches the declared type.
Output arguments must evaluate to a memory location that the callee can read from and write to.
If the callee is an activity that eventually terminates and declares a return value, this return value must be either received into some variable or ignored using a wildcard.&lt;/p&gt;
&lt;p&gt;When control flow reaches a &lt;code&gt;run&lt;/code&gt; statement the sub-activity is immediately called and the control flow is handed over to the callee.
It remains within the callee for as many reactions as it runs (but at least one reaction).
In every reaction inputs are passed though to the callee and its outputs are propagated outside.
Should the callee terminate, the control flow returns to the caller and proceeds with the next statement.&lt;/p&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;// declaration
activity A (a: [8]int32, b: int32) (c: int32) returns bool
    /* some code */
    ...
end

    /* ... inside another activity ... */
    var result: bool
    var array: [8]int32 = {1, 2, 3, 4, 5, 6, 7, 8}
    var output: int32
    // usage
    result = run A(array, 7)(output)
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;cobegin&#34;&gt;Cobegin&lt;/h3&gt;
&lt;p&gt;Concurrent composition is done with the &lt;code&gt;cobegin&lt;/code&gt; statement.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-abnf&#34; data-lang=&#34;abnf&#34;&gt;&lt;span style=&#34;color:#000&#34;&gt;ForkJoin&lt;/span&gt; ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;cobegin&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;&amp;#34;weak&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;StmtBlock&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;&amp;#34;with&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;&amp;#34;weak&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;StmtBlock&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;+ &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;end&amp;#34;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Using &lt;code&gt;cobegin&lt;/code&gt; it is possible to compose arbitrary pieces of code.
The goal is not to parallelise to gain execution speed.
Rather this the language construct to express that two (or more) functionalities should be computed within the same reaction.
As such concurrency is rather a modelling concept in Blech.
The code generator will actually sequentialise the code in a causally correct order.&lt;/p&gt;


&lt;div class=&#34;alert alert-info&#34; role=&#34;alert&#34;&gt;

In the future there will be the possibility to specify truly parallel executions in Blech which can be carried out independently.
&lt;/div&gt;

&lt;h4 id=&#34;example-concurrent-composition&#34;&gt;Example: Concurrent composition&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;
&lt;table style=&#34;border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;&#34;&gt;&lt;tr&gt;&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;&#34;&gt;
&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 1
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 2
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 3
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 4
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 5
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 6
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 7
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 8
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 9
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;10
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;;width:100%&#34;&gt;
&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-txt&#34; data-lang=&#34;txt&#34;&gt;activity P ()
    var x: int32
    var y: int32
    var z: int32
    cobegin
        run A(x)(z)
    with
        run B(y)(x)
    end
end
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;Assume the activities &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; have already been implemented.
In lines 5 &amp;ndash; 9 they are composed concurrently.
This means the control flow of &lt;code&gt;P&lt;/code&gt; is forked into two control flow points.
One resides in &lt;code&gt;A&lt;/code&gt; (line 6) and one in &lt;code&gt;B&lt;/code&gt; (line 8).
With every tick both, &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt;, will perform one reaction.
When both subprograms terminate, &lt;code&gt;P&lt;/code&gt; regains control in line 9 and, in this example, terminates too.
Of course, more than two branches can be combined using more &lt;code&gt;with&lt;/code&gt; branches.
Note that the reaction of &lt;code&gt;B&lt;/code&gt; will be carried out before the reaction of &lt;code&gt;A&lt;/code&gt; due to causality:
First the unique value of &lt;code&gt;x&lt;/code&gt; needs to be set by writer &lt;code&gt;B&lt;/code&gt; before the reader &lt;code&gt;A&lt;/code&gt; may use it.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;cobegin&lt;/code&gt; statement is a composite statement like a &lt;code&gt;repeat&lt;/code&gt; loop or an &lt;code&gt;if&lt;/code&gt; statement.
Control flow can remain within the &lt;code&gt;cobegin&lt;/code&gt; branches for multiple reactions.
However in general the various branches can perform a different number of reactions, possibly infinitely many.
We therefore need to control the termination of &lt;code&gt;cobegin&lt;/code&gt; as a whole using the &lt;code&gt;weak&lt;/code&gt; qualifiers.&lt;/p&gt;
&lt;p&gt;Formally, a &lt;code&gt;cobegin&lt;/code&gt; statement terminates in the reaction in which all strong branches have terminated.
If all branches are weak, the &lt;code&gt;cobegin&lt;/code&gt; statement terminates in the reaction in which some branch terminates.&lt;/p&gt;
&lt;p&gt;In the above example no branch is &lt;code&gt;weak&lt;/code&gt;.
We say all branches are &amp;ldquo;strong&amp;rdquo;.
This means the &lt;code&gt;cobegin&lt;/code&gt; statement terminates when &lt;em&gt;all&lt;/em&gt; of its branches have terminated.
Branches that finish earlier (have fewer reaction to do) will simply do nothing until the last strong branch has terminated.
The following two examples illustrate the usage of the &lt;code&gt;weak&lt;/code&gt; qualifier.&lt;/p&gt;
&lt;h4 id=&#34;example-weak-and-strong-branches&#34;&gt;Example: Weak and strong branches&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;/* ... inside some activity ... */
var res: nat8
cobegin weak
    // non-terminating branch
    repeat
        await true
        out1 = (out1 + 1) % 100
    end
with
    // terminates once a key is pressed
    res = run ReadKeyStroke()
end
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The first branch contains an infinite loop in the sense that every iteration ends in a pause but the number of reactions is unbounded.
The loop is placed into a weak branch that allows to terminate the loop at the end of some reaction.
The second branch contains an activity call that is expected to return some value eventually.
In the reaction in which the result is returned the weak branch will be aborted (after it has done one iteration) and the control flow continues with the next statement following the &lt;code&gt;cobegin&lt;/code&gt;.&lt;/p&gt;
&lt;h4 id=&#34;example-all-branches-weak&#34;&gt;Example: All branches weak&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;cobegin weak
    await isButtonPressed
with weak
    await hasReceivedSignal
end
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;In this example there are no strong branches.
The first branch to terminate will abort all others.
In this example it means as soon as &lt;code&gt;isButtonPressed&lt;/code&gt; or &lt;code&gt;hasReceivedSignal&lt;/code&gt; is true (or both are true!) the &lt;code&gt;cobegin&lt;/code&gt; statement terminates and control flow continues with the next statement.&lt;/p&gt;
&lt;h3 id=&#34;abort-and-reset&#34;&gt;Abort and reset&lt;/h3&gt;
&lt;p&gt;There are two kinds of synchronous preemptions built into Blech.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-abnf&#34; data-lang=&#34;abnf&#34;&gt;&lt;span style=&#34;color:#000&#34;&gt;Preemption&lt;/span&gt; ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;when&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Condition&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;&amp;#34;abort&amp;#34;&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;reset&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;StmtBlock&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;end&amp;#34;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;When control flow enters a preemption the statements in its body, denoted by &lt;code&gt;StmtBlock&lt;/code&gt; in the grammar, are executed until the reaction ends in an &lt;code&gt;await&lt;/code&gt; or &lt;code&gt;run&lt;/code&gt; statement.
Subsequently, when a reaction resumes execution inside the body, first the &lt;code&gt;when&lt;/code&gt; condition is checked.
If it is false, the execution starts as usual.
Otherwise the body is preempted &lt;em&gt;before&lt;/em&gt; any statement is executed or expression is evaluated inside the body.
There are two variants of preemptions.
&lt;code&gt;abort&lt;/code&gt; means that control flow jumps to the &lt;code&gt;end&lt;/code&gt; of the preemption statement.
&lt;code&gt;reset&lt;/code&gt; means that control flow restarts at the beginning of &lt;code&gt;StmtBlock&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Note that&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;when Condition reset P end
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;is syntactic sugar for&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;var hasTerminated = false
repeat
    when Condition abort
        P
        hasTerminated = true
    end
until hasTerminated end
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;where &lt;code&gt;hasTerminated&lt;/code&gt; is a fresh boolean variable.&lt;/p&gt;
&lt;p&gt;It is, of course, possible that the body is left instantaneously within one reaction.
In this case the preemption is irrelevant for the flow of control.&lt;/p&gt;


&lt;div class=&#34;alert alert-warning&#34; role=&#34;alert&#34;&gt;

The preemption condition is &lt;em&gt;not&lt;/em&gt; checked when the control flow enters the body.
The &lt;code&gt;when&lt;/code&gt; condition is only checked when control flow resumes from within the body.
Wrap the preemption inside an &lt;code&gt;if&lt;/code&gt; statement in case you want to check the condition before entering the body.
&lt;/div&gt;

&lt;h4 id=&#34;example-abort-and-reset&#34;&gt;Example: Abort and Reset&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;
&lt;table style=&#34;border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;&#34;&gt;&lt;tr&gt;&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;&#34;&gt;
&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 1
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 2
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 3
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 4
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 5
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 6
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 7
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 8
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 9
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;10
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;11
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;12
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;13
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;;width:100%&#34;&gt;
&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-txt&#34; data-lang=&#34;txt&#34;&gt;activity A (in1: bool) (out1: uint8)
    // do something ...
    
    when in1 abort
        out1 = 1
        await true
        out1 = 2
        await true
        out1 = 3
    end
    
    // do something else ...
end
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;The statement in line 4 says that &lt;code&gt;when&lt;/code&gt; a reaction &lt;em&gt;starts&lt;/em&gt; in the block lines 5 &amp;ndash; 9, it is checked whether &lt;code&gt;in1&lt;/code&gt; is true and in that case the control flow skips to line 10.
Thus when control flow reaches line 4 it will immediately proceed to line 5, set &lt;code&gt;out1&lt;/code&gt; accordingly and finish this reaction in line 6 (regardless of the value of &lt;code&gt;in1&lt;/code&gt;).
The next reaction starts by checking the abort condition &lt;code&gt;in1&lt;/code&gt;.
If it is true we skip the rest of the block and proceed to line 10.
Otherwise, we check the condition of the &lt;code&gt;await&lt;/code&gt; statement which here is vacuously true and the reaction proceeds to line 7 and finishes in line 8.
The same reasoning applies in line 8: the execution is possibly aborted before setting &lt;code&gt;out1&lt;/code&gt; to 3.
In any case, the block is left in line 10.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;abort&lt;/code&gt; statement is useful whenever we want to skip over a sequence of reactions when we detect some issue at the beginning of a reaction.
Sometimes instead of skipping ahead we would like to restart a sequence of reactions.
For this we may use the &lt;code&gt;reset&lt;/code&gt; statement.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;activity MyAct (in1: bool) (out1: uint8)
    // do something ...
    
    when in1 reset // reset instead of abort
        out1 = 1
        await true
        out1 = 2
        await true
        out1 = 3
    end
    
    // do something else ...
end
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;It behaves just like the &lt;code&gt;abort&lt;/code&gt; statement except it jumps to line 4 if &lt;code&gt;in1&lt;/code&gt; is true.&lt;/p&gt;
&lt;h2 id=&#34;imperative-control-flow&#34;&gt;Imperative control flow&lt;/h2&gt;
&lt;p&gt;All of the following statements are known from mainstream imperative programming languages.
They may be used inside both, activities and functions.&lt;/p&gt;
&lt;h3 id=&#34;assignment&#34;&gt;Assignment&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-abnf&#34; data-lang=&#34;abnf&#34;&gt;&lt;span style=&#34;color:#000&#34;&gt;Assignment&lt;/span&gt; ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;LhsExpr&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;=&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;RhsExpr&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;do-block&#34;&gt;Do block&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-abnf&#34; data-lang=&#34;abnf&#34;&gt;&lt;span style=&#34;color:#000&#34;&gt;DoBlock&lt;/span&gt; ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;do&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;StmtBlock&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;end&amp;#34;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The &lt;code&gt;do&lt;/code&gt; block may be used to define local scopes.&lt;/p&gt;
&lt;h4 id=&#34;example-local-scopes&#34;&gt;Example: Local scopes&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;function f ()
    do
        var x: int8 = 5
    end
    // x is out of scope here
end
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;if&#34;&gt;If&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-abnf&#34; data-lang=&#34;abnf&#34;&gt;&lt;span style=&#34;color:#000&#34;&gt;IfStmt&lt;/span&gt; ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;if&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Condition&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;then&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;StmtBlock&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;&amp;#34;elseif&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Condition&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;then&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;StmtBlock&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;]&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;&amp;#34;else&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;StmtBlock&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;end&amp;#34;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;while&#34;&gt;While&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-abnf&#34; data-lang=&#34;abnf&#34;&gt;&lt;span style=&#34;color:#000&#34;&gt;WhileLoop&lt;/span&gt; ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;while&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Condition&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;repeat&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;StmtBlock&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;end&amp;#34;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;When using a loop in an activity, there must be some pause on every control flow path through the loop body.
This is not necessary for loops inside functions.
Note that using &lt;code&gt;while&lt;/code&gt; loops in activities may lead to unexpected error messages because we deliberately &lt;em&gt;do not&lt;/em&gt; evaluate the condition at compile time even if it is trivially true or false.&lt;/p&gt;
&lt;p&gt;For example:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;activity Toggle()(out:bool)
    while true repeat
        out = not out
        await true
    end
end
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This program will not compile because the compiler thinks there is a control flow path that does not enter the loop and immediately terminates the activity.
Since activities must not be instantaneous this program is rejected.
Use &lt;code&gt;repeat&lt;/code&gt; loops instead to avoid this spurious control flow paths that possibly skip the loop.&lt;/p&gt;
&lt;h3 id=&#34;repeat&#34;&gt;Repeat&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-abnf&#34; data-lang=&#34;abnf&#34;&gt;&lt;span style=&#34;color:#000&#34;&gt;RepeatLoop&lt;/span&gt; ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;repeat&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;StmtBlock&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;&amp;#34;until&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Condition&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;end&amp;#34;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;repeat&lt;/code&gt; loops guarantee that control flow does enter the loop body at least once.
Endless loops (without the &lt;code&gt;until&lt;/code&gt; condition) may only be used in activities.
Again, when using a loop in an activity, there must be some pause on every control flow path through the loop body.
This is not necessary for loops inside functions.&lt;/p&gt;
&lt;h3 id=&#34;return&#34;&gt;Return&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-abnf&#34; data-lang=&#34;abnf&#34;&gt;&lt;span style=&#34;color:#000&#34;&gt;ReturnStmt&lt;/span&gt; ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;return&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;RhsExpr&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Void activities and functions can use &lt;code&gt;return&lt;/code&gt; without an expression to terminate at some point before control flow reaches the last statement.&lt;/p&gt;
&lt;h4 id=&#34;example-return-from-void-function&#34;&gt;Example: Return from void function&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;function setSpeed (velocity: float32) ()
    if velocity &amp;lt; 0 then
        return
    end

    if not isMotorReady() then
        return
    end
    
    halSetSpeed(velocity) // call device driver
end
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This simple example assumes we implement a wrapper for calling a hardware device driver.
In order to avoid an if-then-else cascade &lt;code&gt;setSpeed&lt;/code&gt; tests the prerequisites individually and returns in case some of them is not met.&lt;/p&gt;
&lt;p&gt;Activities and functions that declare a return type must return a value of this type on every control flow path that reaches the end of the program body.&lt;/p&gt;
&lt;p&gt;Activities may only return from their main thread.
In other words &lt;code&gt;return&lt;/code&gt; must not occur inside any branch of a &lt;code&gt;cobegin&lt;/code&gt; statement.&lt;/p&gt;
&lt;p&gt;Mind the difference between activity return values and activity output values.
Outputs are set in every reaction of the activity.
A return value is returned precisely once in the reaction that terminates the activity.&lt;/p&gt;
&lt;h4 id=&#34;example-return-from-activity&#34;&gt;Example: Return from activity&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;activity A (in: int32) (out: int32) returns nat8
    var retcode: nat8
    var x: int32
    cobegin weak
        run B(in)(x)
    with
        retcode = run C(x)(out)
    end
    return retcode
end
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;In every reaction &lt;code&gt;in&lt;/code&gt; is propagated to &lt;code&gt;B&lt;/code&gt; and &lt;code&gt;out&lt;/code&gt; is propagated from &lt;code&gt;C&lt;/code&gt; to the caller.
Only when &lt;code&gt;C&lt;/code&gt; terminates the variable &lt;code&gt;retcode&lt;/code&gt; is updated, the &lt;code&gt;cobegin&lt;/code&gt; statement is terminated and the &lt;code&gt;retcode&lt;/code&gt; is returned to the caller.&lt;/p&gt;
&lt;h3 id=&#34;function-call&#34;&gt;Function call&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-abnf&#34; data-lang=&#34;abnf&#34;&gt;&lt;span style=&#34;color:#000&#34;&gt;FunctionCallStmt&lt;/span&gt; ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Identifier&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;RhsArgList&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;LhsArgList&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Blech distinguishes between a function call statement and a function call expression.
On the statement level only void functions may be called.&lt;/p&gt;
&lt;p&gt;In summary, a block of statements in Blech is given by the following grammar.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-abnf&#34; data-lang=&#34;abnf&#34;&gt;&lt;span style=&#34;color:#000&#34;&gt;StmtBlock&lt;/span&gt; ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; 
      &lt;span style=&#34;color:#000&#34;&gt;Pause&lt;/span&gt;
    | &lt;span style=&#34;color:#000&#34;&gt;ActivityCall&lt;/span&gt;
    | &lt;span style=&#34;color:#000&#34;&gt;ForkJoin&lt;/span&gt;
    | &lt;span style=&#34;color:#000&#34;&gt;Preemption&lt;/span&gt;
    | &lt;span style=&#34;color:#000&#34;&gt;Assignment&lt;/span&gt;
    | &lt;span style=&#34;color:#000&#34;&gt;DoBlock&lt;/span&gt;
    | &lt;span style=&#34;color:#000&#34;&gt;IfStmt&lt;/span&gt;
    | &lt;span style=&#34;color:#000&#34;&gt;WhileLoop&lt;/span&gt;
    | &lt;span style=&#34;color:#000&#34;&gt;RepeatLoop&lt;/span&gt;
    | &lt;span style=&#34;color:#000&#34;&gt;ReturnStmt&lt;/span&gt;
    | &lt;span style=&#34;color:#000&#34;&gt;FunctionCallStmt&lt;/span&gt;
    | &lt;span style=&#34;color:#000&#34;&gt;StmtBlock&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;StmtBlock&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Depending on whether statements are used in an activity or a function their use may be restricted or prohibited (see above).
The optional semicolons in the grammar indicate that it is possible to separate statements in a sequence using semicolons.
We suggest to avoid writing any semicolons unless two (or more) statements are written in one line.&lt;/p&gt;
&lt;h3 id=&#34;semicolons-in-blech&#34;&gt;Semicolons in Blech&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;function f()
    var x: int8 = 0; // do not clutter your code with superfluous &amp;quot;;&amp;quot;
    var y: int8 = 1  // preferred semicolon free style

    x = 7; y = y + x // ok, but usually it is better to write two lines
    x = 7 y = y + x  // compiles but is hardly readable, do not do that
end
&lt;/code&gt;&lt;/pre&gt;
      </description>
    </item>
    
    <item>
      <title>Docs: Local and external variables</title>
      <link>https://boschresearch.github.io/blech-doc/docs/blechc-development/external-vars/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://boschresearch.github.io/blech-doc/docs/blechc-development/external-vars/</guid>
      <description>
        
        
        &lt;h2 id=&#34;local-variables&#34;&gt;Local variables&lt;/h2&gt;
&lt;p&gt;Variables declared with the scope of an activity are persistent.
They keep their value over multiple reactions.
Hence, in the generated code, they are stored outside the step-function of the given activity.
Instead they are passed as a context with every call of the step-function.&lt;/p&gt;
&lt;p&gt;Previous values however need not be stored in this static context.
In the generated code, they can be automatic variables (stack allocated variables) of the generated step-function.
The step-function itself will create the prev variables (where needed) and fill them before the actual step is carried out.&lt;/p&gt;
&lt;p&gt;Special attention has to be given to the reaction in which the declaration of the local variable takes place.
Here the local variable assumes its first value.
This is defined to be the prev value and thus the prev variable has to be reset here once.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;...
var x: int32 = 7 // prev x = 7
cobegin
    run B(prev y)(x) // x may have changed
with
    run A(prev x)(y) // prev x is guaranteed to be 7 in the first reaction
end
...
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;externa-variables&#34;&gt;Externa Variables&lt;/h2&gt;
&lt;p&gt;External variables (inside the activity scope) are dual to local variables in terms of code generation.
We do not need to store external variables in the static context which is passed to the step-function.
Instead an external variable will be represented by an automatic variable which is set at the beginning of the reaction using the value of the actual external C-variable that it is bound to.
At the end of the reaction, the final value is written back to the external C-variable (if it is a &lt;code&gt;var&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;Previous values of external variables on the other hand must be persisted in static memory.
This is to guarantee synchronous semantics, i.e. the prev value really is the value that the last reaction ended with
(while the value of the external variable is volatile and may have changed arbitrarily between reactions).
The code generator will create an extra local activity variable and add it to the list of local variables that are stored in the context.
The value of the prev variable will be set &lt;em&gt;at the end&lt;/em&gt; of each reaction, so it can be used in the next reaction.&lt;/p&gt;
&lt;p&gt;Again, special treatment is required in the code block that represents the reaction in which the declaration of the external variable becomes active.
Here, as before, the prev value has to be set once so it is defined in the case that the prev value is used in the same reaction.&lt;/p&gt;
&lt;h2 id=&#34;effects-on-compilation-contexts&#34;&gt;Effects on compilation contexts&lt;/h2&gt;
&lt;p&gt;If necessary, the function &lt;code&gt;ActivityTranslator.cpAction&lt;/code&gt; adds the external variable with a &lt;code&gt;prev_&lt;/code&gt; infix in its name to the &lt;code&gt;Compilation.iface.locals&lt;/code&gt; of the current activity.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ActivityTranslator.makeActCall&lt;/code&gt; transports the locals of the called activity to the interface of the current one which includes the prev&amp;rsquo;ed version of external variables.
In order to be able to print this interface as C code, the variables are added to the dictionary of known declarations in the type check context (&lt;code&gt;ctx.tcc.nameToDecl&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;Since the entry point activity is never called from within the Blech program the above mechanism of adding variables to the type check context is repeated in &lt;code&gt;ActivityTranslator.translate&lt;/code&gt; (for the entry point activity only).&lt;/p&gt;
&lt;h2 id=&#34;effects-on-c-code-generation&#34;&gt;Effects on C-code generation&lt;/h2&gt;
&lt;p&gt;Printing external constants or params does not require any additional modifications. The given binding is simply inserted. For &lt;code&gt;extern let&lt;/code&gt; and &lt;code&gt;extern var&lt;/code&gt; additional effort is required.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;External variables&lt;/p&gt;
&lt;p&gt;Whenever an external variable is accessed as a right-hand-side, left-hand-side or the input or output argument to a call, it needs to be rendered differently than local activity variables.
This is because external variables are generated as automatic variables in the scope of the step-function (instead of being passed in with the context).
Thus they need to be rendered like local variables in Blech functions.
This is achieved by hooking in the &lt;code&gt;isExtCurVar&lt;/code&gt; function in the call of the &lt;code&gt;cpRenderData&lt;/code&gt;.
It will set the &lt;code&gt;subProgDecl&lt;/code&gt; to &lt;code&gt;Function&lt;/code&gt; if the variable name to be rendered is an access to the current memory location of an external variable.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Access to previous locations of external variables&lt;/p&gt;
&lt;p&gt;Usually the previous value is stored in an automatic variable of the step-function and is accessed accordingly. The name is mangled by prepending a &lt;code&gt;prev_&lt;/code&gt; to the QName of the variable.
However previous values of external variables are stored in the context. Thus they need to be accessed like a local variable. The &lt;code&gt;prev_&lt;/code&gt; infix is already mangled into the QName that is stored in the context.
Thus &lt;code&gt;cpRenderData&lt;/code&gt; will change &lt;code&gt;timepoint&lt;/code&gt; to &lt;code&gt;Current&lt;/code&gt; and add the &lt;code&gt;prev_&lt;/code&gt; infix into the name to be rendered.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Copy-in / copy-out&lt;/p&gt;
&lt;p&gt;The function &lt;code&gt;ActivityTranslator.translate&lt;/code&gt; generates code for&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Copying the values from the bound external C-variables to the local memory inside the step-function at the beginning of the reaction.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Copying back the final results back to the bound external C-variables at the end of the reaction.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;(If necessary,) setting the previous memory to the final current value of the external variable such that in the next reaction the prev value can be used.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;effects-on-json-trace-printing&#34;&gt;Effects on JSON trace printing&lt;/h2&gt;
&lt;p&gt;Since prev locations of external variables become local activity variables and are added to the type check context, they are printed in the trace along with the normal variables.
Note however that the value shown in the trace is the prev value for the &lt;em&gt;next&lt;/em&gt; reaction.&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: Git workflow</title>
      <link>https://boschresearch.github.io/blech-doc/docs/blechc-development/git-workflow/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://boschresearch.github.io/blech-doc/docs/blechc-development/git-workflow/</guid>
      <description>
        
        
        &lt;h2 id=&#34;branches&#34;&gt;Branches&lt;/h2&gt;
&lt;p&gt;For the Blech compiler development we use branches and roughly follow the &lt;a href=&#34;https://gist.github.com/digitaljhelms/4287848&#34; target=&#34;_blank&#34;&gt;Git/Github branching standards &amp;amp; conventions&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;The contained &lt;a href=&#34;https://gist.github.com/digitaljhelms/4287848#workflow-diagram&#34; target=&#34;_blank&#34;&gt;workflow diagram&lt;/a&gt;
 visualizes this in a nice way.&lt;/p&gt;
&lt;p&gt;Since we did not release a stable version until now, we do not have stable branch but only a master branch that reflects the evolution of the language and gets tagged from time to time.&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: Declarations</title>
      <link>https://boschresearch.github.io/blech-doc/docs/user-manual/declarations/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://boschresearch.github.io/blech-doc/docs/user-manual/declarations/</guid>
      <description>
        
        
        &lt;p&gt;Declarations introduce new names for entities in the program.
Declarable entities include&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;activities&lt;/li&gt;
&lt;li&gt;functions&lt;/li&gt;
&lt;li&gt;types&lt;/li&gt;
&lt;li&gt;data storage&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In the future more of such entities may be added to the language such as clocks and physical units.&lt;/p&gt;
&lt;p&gt;Every declaration exists in a &lt;em&gt;lexical scope&lt;/em&gt;.
Scopes define the visibility of a name.
The top-level or file scope is the most global scope in Blech.
Functions, activities and types are defined here.
Entities in the top-level scope are visible everywhere in the file.
Every block introduces a sub-scope.
For example, a function body is a local scope.
Variables defined in this scope are visible in this function but not outside of it.
Composite statements, such as the &lt;code&gt;repeat&lt;/code&gt; loop introduce their statement-local scope. This allows to introduce a variable that is visible during the iteration through this loop and not outside of it.&lt;/p&gt;


&lt;div class=&#34;alert alert-primary&#34; role=&#34;alert&#34;&gt;

Once we implement a module system for Blech, the mechanisms for controlling visibility will need to be elaborated in more detail.
&lt;/div&gt;

&lt;p&gt;In Blech, declarations not only introduce a name but also &lt;em&gt;define&lt;/em&gt; what this name represents. For example, a function declaration will specify a function body.
That is the block of statements that are executed when this functions is called.
The definition may refer to names that were previously declared.&lt;/p&gt;


&lt;div class=&#34;alert alert-warning&#34; role=&#34;alert&#34;&gt;

Declare before use! Even if, for example, functions are defined on the same scope, a function can only call other functions that have been declared before.
&lt;/div&gt;

&lt;p&gt;In the following we discuss the various entities that can be defined in a Blech program.&lt;/p&gt;
&lt;h2 id=&#34;data&#34;&gt;Data&lt;/h2&gt;
&lt;p&gt;Data declarations consist of an access and placement qualifier, an identifier, a data type and an initialisation.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-abnf&#34; data-lang=&#34;abnf&#34;&gt;&lt;span style=&#34;color:#000&#34;&gt;DataDeclaration&lt;/span&gt; ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Qualifier&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Identifier&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;:&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Type&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;=&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Init&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;A variable declaration:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;var x: int32 = 17
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The type is either a built-in type or a name of a user defined type.
Built-in types are discussed in the next chapter.
Type declarations are discussed in the next section.&lt;/p&gt;
&lt;p&gt;Initialisers are expressions that evaluate to a value that matches this declaration&amp;rsquo;s data type. Expressions (including literals) will be discussed in a later chapter.&lt;/p&gt;
&lt;h3 id=&#34;qualifiers&#34;&gt;Qualifiers&lt;/h3&gt;
&lt;p&gt;There are four possible qualifiers.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-abnf&#34; data-lang=&#34;abnf&#34;&gt;&lt;span style=&#34;color:#000&#34;&gt;Qualifier&lt;/span&gt; ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;const&amp;#34;&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;param&amp;#34;&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;let&amp;#34;&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;var&amp;#34;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;const&lt;/code&gt; qualified data is relevant for the compilation phase only and does not have any representation in memory at run time.
Typical use cases for &lt;code&gt;const&lt;/code&gt; are sizes of data structures, addresses in memory, &amp;hellip;
In C, these are represented by &lt;code&gt;#define&lt;/code&gt; macros, which, too, have no representation after the preprocessor finishes.
Hence &lt;em&gt;using const on arrays (or structs containing arrays), albeit possible, is not advisable&lt;/em&gt; and produces inefficient code because temporary variables have to be created (and filled) at runtime for every (non-constant) access to these arrays.
Instead consider &lt;code&gt;param&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;param&lt;/code&gt; qualified data has a representation in memory at run time but cannot be changed by the running program for its entire lifetime (it can only be reflashed).
Typical use cases for &lt;code&gt;param&lt;/code&gt; are characteristics maps or other immutable lookup data structures.
The name &amp;ldquo;param&amp;rdquo; indicates that such data is a parameter of the final compilation result.
Tools exist to customise such parameters in a binary file directly in order to adapt the given software to a variant of a product.
Like with &lt;code&gt;const&lt;/code&gt; data, the &lt;code&gt;param&lt;/code&gt; value must be initialised with constant expressions.
You cannot write the following&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;function f (input: int32)
   param x: int32 = input // error!
end
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This is because the value of &lt;code&gt;input&lt;/code&gt; is determined at &lt;em&gt;runtime&lt;/em&gt; but &lt;code&gt;x&lt;/code&gt; must be initialised at &lt;em&gt;compile time&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;const&lt;/code&gt; and &lt;code&gt;param&lt;/code&gt; data may be declared at top level as well as inside functions or activities.
The other two qualifiers &lt;code&gt;let&lt;/code&gt; and &lt;code&gt;var&lt;/code&gt; indicate local data and may &lt;em&gt;only&lt;/em&gt; be used inside functions or activities.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;let&lt;/code&gt; declares immutable data in the control flow of a program.
Finally, &amp;lsquo;var&amp;rsquo; declares the usual mutable variable.
Initialisation may be omitted for mutable variables. In this case the Blech compiler will automatically initialise the variable with its type&amp;rsquo;s default value.
The type annotation may be omitted if the type can be unambiguously determined from the initialisation expression.&lt;/p&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;const LEN: int32 = 8
param lut: [LEN]float64 = {1.0, 0.5, 0.25, 0.125} // LEN is constant and may be used here
                                                  // the array literal will be filled with additional 0&#39;s up to length LEN.
function f()
    let i = LEN - 7 // i is deduced to be int32
    var x = lut[i] // x is deduced to be float64
                   // and equals 0.5 in this case
end
&lt;/code&gt;&lt;/pre&gt;

&lt;div class=&#34;alert alert-info&#34; role=&#34;alert&#34;&gt;

No global variables in Blech!
We deliberately prohibit the use of &lt;code&gt;let&lt;/code&gt; and &lt;code&gt;var&lt;/code&gt; outside subprogram scopes because we believe this leads to better understandable, easier to integrate and unit-testable programs.
&lt;/div&gt;



&lt;div class=&#34;alert alert-warning&#34; role=&#34;alert&#34;&gt;

Confusion may arise about the difference between &lt;code&gt;param&lt;/code&gt; and &lt;code&gt;let&lt;/code&gt;.
They both qualify immutable data in memory.
They could be even stored in the same way which however is a compiler implementation detail and none of the concerns of the programmer.
The crucial difference is that &lt;code&gt;let&lt;/code&gt; takes values at runtime.
It is immutable throughout the scope where it has been declared.
Once the scope is left and re-entered, the value of that &lt;code&gt;let&lt;/code&gt; variable may be re-initialised. (In the literature this is sometimes dramatically referred to as &amp;ldquo;re-incarnation&amp;rdquo;.)
As stated above, &lt;code&gt;param&lt;/code&gt; data cannot be changed by the running program at all, it is completely static.
&lt;/div&gt;



&lt;div class=&#34;alert alert-warning&#34; role=&#34;alert&#34;&gt;

The word &amp;ldquo;parameter&amp;rdquo; appears in two notions. One is the &amp;ldquo;formal parameter&amp;rdquo; of a function or activity.
The other is the &amp;ldquo;param&amp;rdquo; qualifier for immutable data.
The first parametrises a function (ar activity), the second parametrises a whole binary.
We try to make clear which one we mean throughout this document. Usually it should be apparent from context however.
&lt;/div&gt;

&lt;h2 id=&#34;user-defined-types&#34;&gt;User defined types&lt;/h2&gt;
&lt;p&gt;The programmer may define a data structure using the &lt;code&gt;struct&lt;/code&gt; keyword.


&lt;div class=&#34;alert alert-primary&#34; role=&#34;alert&#34;&gt;
&lt;h4 class=&#34;alert-heading&#34;&gt;TODO&lt;/h4&gt;
See the chapter on &lt;a href=&#34;https://boschresearch.github.io/blech-doc/docs/user-manual/types/#structure-types&#34;&gt;struct types&lt;/a&gt; for more details.
&lt;/div&gt;
&lt;/p&gt;
&lt;h2 id=&#34;subprograms&#34;&gt;Subprograms&lt;/h2&gt;
&lt;p&gt;Blech discerns two type of subprograms: &lt;code&gt;activity&lt;/code&gt; and &lt;code&gt;function&lt;/code&gt;.
Their behaviour is different. Activities must pause at least once whereas functions need to terminate within one reaction. Functions are therefore called &amp;ldquo;instantaneous&amp;rdquo;.
The precise differences will be worked out in the chapter on Blech statements.
From a syntactic declaration point of view there is hardly any difference.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-abnf&#34; data-lang=&#34;abnf&#34;&gt;&lt;span style=&#34;color:#000&#34;&gt;ProgramDeclaration&lt;/span&gt; ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;&amp;#34;singleton&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;ProgramType&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Identifier&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;ParamList&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;ParamList&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;&amp;#34;returns&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Type&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;StmtBlock&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;end&amp;#34;&lt;/span&gt;
&lt;span style=&#34;color:#000&#34;&gt;ProgramType&lt;/span&gt;        ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;function&amp;#34;&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;activity&amp;#34;&lt;/span&gt;
&lt;span style=&#34;color:#000&#34;&gt;ParamList&lt;/span&gt;          ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;()&amp;#34;&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;(&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;ParamDeclaration&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;&amp;#34;,&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;ParamDeclaration&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;)&amp;#34;&lt;/span&gt;
&lt;span style=&#34;color:#000&#34;&gt;ParamDeclaration&lt;/span&gt;   ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Identifier&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;:&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Type&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;There are two parameter lists.
The first lists declares formal parameters that may only be read (like &lt;code&gt;let&lt;/code&gt; variables), the second list declares formal parameters that may be both read and written (like &lt;code&gt;var&lt;/code&gt; variables).
In particular the two lists are useful for activities which, in every reaction, receive a list of read-only &lt;em&gt;inputs&lt;/em&gt;, perform some calculation and set the list of read-write &lt;em&gt;outputs&lt;/em&gt;.
We will therefore often refer to these two parameter lists as &amp;ldquo;input list&amp;rdquo; and &amp;ldquo;output list&amp;rdquo;.&lt;/p&gt;
&lt;p&gt;The programming model is that all variables are passed by reference (even though in reality the compiler will optimise this into by-value for simple value typed inputs).&lt;/p&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;function add (x: int32, y: int32) returns int32
   return x + y
end

@[EntryPoint]
activity A (in: int32)(out: int32)
   repeat
      out = add(in, out)
      await true
   end
end
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The example above is a valid Blech program that sums all inputs over all time steps.
Note that &lt;code&gt;add&lt;/code&gt; omits an output list and &lt;code&gt;A&lt;/code&gt; does not declare any return type.
We call functions or activities that do not return anything &amp;ldquo;void&amp;rdquo; but unlike C we do not have a void type in the language.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;@[EntryPoint]&lt;/code&gt; annotation tells the compiler that &lt;code&gt;A&lt;/code&gt; is the main program of this file. Every Blech file must have precisely one entry point activity.
&lt;em&gt;(That is until we have a module system that allows to write libraries that may have no single entry point at all).&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;singleton&lt;/code&gt; keyword is optional and may be used to indicate that there may exist only one instance of this subprogram in a concurrent context.
For example, this is useful to indicate early on in the development phase that an activity will have some interaction with the external environment.
The caller of a singleton callee automatically becomes a singleton, too.&lt;/p&gt;
&lt;h2 id=&#34;external-declarations&#34;&gt;External Declarations&lt;/h2&gt;
&lt;p&gt;Sometimes it is useful to access global variables or functions of a C program.
This allows for example to make use of existing libraries.
Such variables and functions are &lt;em&gt;external&lt;/em&gt; from the point of view of a Blech program.
Annotations are required to tell the compiler how to code-generate access to these external entities.&lt;/p&gt;
&lt;p&gt;Formally, we have the following syntax.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-abnf&#34; data-lang=&#34;abnf&#34;&gt;&lt;span style=&#34;color:#000&#34;&gt;ExternFunctionDeclaration&lt;/span&gt; ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;extern&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;&amp;#34;singleton&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;function&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Identifier&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;ParamList&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;ParamList&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;returns&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Type&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;]&lt;/span&gt;
&lt;span style=&#34;color:#000&#34;&gt;ExternDataDeclaration&lt;/span&gt;     ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;extern&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Qualifier&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Identifier&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;:&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Type&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Obviously, external functions have no body and external variables cannot be initialised.
As before, external functions may be characterised as &lt;code&gt;singleton&lt;/code&gt; which means such a function may not be called concurrently. This is useful when the external function to be called is not a pure function because it either returns a volatile value or has some effect on the environment. Calling such a function concurrently would violate the synchrony assumptions and lead to unexpected results.&lt;/p&gt;
&lt;p&gt;External declarations additionally require annotations which we introduce by example below.&lt;/p&gt;
&lt;p&gt;[IMPORTANT]
Note that the type-safety and causality guarantees of Blech vanish once you interact with an external C implementation. That means the Blech compiler relies on the assumption that the specified annotations and interfaces are correct. We&amp;rsquo;ll point out a few caveats below.&lt;/p&gt;
&lt;h3 id=&#34;external-constants&#34;&gt;External constants&lt;/h3&gt;
&lt;p&gt;In C, constant values may be defined using macros or &lt;code&gt;const&lt;/code&gt; variables.
In order to make these values available in Blech, external constants may be declared.
External constant declarations may appear in any scope.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;@[CConst (binding = &amp;quot;PI&amp;quot;, header = &amp;quot;math.h&amp;quot;)]
extern const pi: float64
@[CParam (binding = &amp;quot;characteristics&amp;quot;, header = &amp;quot;magic.h&amp;quot;)]
extern param map: [10]float32
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Both Blech qualifiers &lt;code&gt;const&lt;/code&gt; and &lt;code&gt;param&lt;/code&gt; are supported.
They require a &lt;code&gt;CConst&lt;/code&gt; or a &lt;code&gt;CParam&lt;/code&gt; annotation respectively.
However they have more of a documentation character rather than any functional difference.
Both will evaluate whatever expression is given in the binding at runtime.
This is the reason why external constants cannot be used for constant expression evaluation in Blech &amp;ndash; their value is unknown at compile time.
While you can, for example, use a Blech constant to parametrise an array length, you cannot do so using an external constant.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;binding&lt;/code&gt; annotation attribute may contain any expression that can be evaluated in C.&lt;/p&gt;
&lt;p&gt;By design the Blech compiler generates C code that links with other C code but at no point in time does the Blech compiler &amp;ldquo;look into&amp;rdquo; C header or implementation files, nor does it try to evaluate any C-bindings.&lt;/p&gt;
&lt;h3 id=&#34;local-external-variables&#34;&gt;Local external variables&lt;/h3&gt;
&lt;p&gt;The aforementioned constants may be declared in local scopes as well.
Additionally, local Blech variables that link to external global variables may be declared inside activities (but not in functions).&lt;/p&gt;
&lt;p&gt;[NOTE]
There is no semantical reason why external variables cannot be declared inside functions. It is simply due to compiler implementation pragmatics that we exclude this possibility as of now.&lt;/p&gt;
&lt;p&gt;Access to external variables is useful to keep interfaces slim. That is you do not need to pass all data into the entry point activity and down the call chain to the piece of code that actually needs this data and then propagate the results back up this chain to the entry point to communicate the updated values to the environment.
These variables follow the same rules as the usual activity-local variables.&lt;/p&gt;
&lt;p&gt;Read-only external variables are annotated with the &lt;code&gt;CInput&lt;/code&gt; annotation.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;@[CInput (binding = &amp;quot;PIN_7&amp;quot;, header = &amp;quot;head.h&amp;quot;)]
extern let isButtonPressed: bool
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This example assumes there is either a C macro or a C variable &lt;code&gt;PIN_7&lt;/code&gt; that returns a volatile boolean value indicating a button press.&lt;/p&gt;
&lt;p&gt;The declaration creates a local variable inside the enclosing activity.
It serves as a copy-in buffer.
When the activity starts a reaction the value of &lt;code&gt;PIN_7&lt;/code&gt; is copied into &lt;code&gt;isButtonPressed&lt;/code&gt;.
Within the Blech program we can only access the buffer &lt;code&gt;isButtonPressed&lt;/code&gt; and thereby have the guarantee that the value does not change during one reaction.
This corresponds to the semantics of activity input parameters.&lt;/p&gt;
&lt;p&gt;An activity that declares an immutable external variable does not become a singleton.
Concurrent instances may exist but they may contain different values for the same external variable if it is volatile.&lt;/p&gt;
&lt;p&gt;Read-write external variables are annotated with the &lt;code&gt;COutput&lt;/code&gt; annotation.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;@[COutput (binding = &amp;quot;PIN_7&amp;quot;, header = &amp;quot;head.h&amp;quot;)]
extern var isButtonPressed: bool
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Here at the beginning of a reaction the value of &lt;code&gt;PIN_7&lt;/code&gt; is copied in.
During a reaction the variable &lt;code&gt;isButtonPressed&lt;/code&gt; can be modified as usual.
At the end of the reaction the value of &lt;code&gt;isButtonPressed&lt;/code&gt; is copied out to &lt;code&gt;PIN_7&lt;/code&gt;.
This guarantees a stable output behaviour. Intermediate changes to the local variable &lt;code&gt;isButtonPressed&lt;/code&gt; are not observable by the environment.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;prev&lt;/code&gt; operator may be used on external variables.
It returns the value that the variable held at the end of the previous reaction.
This behaviour corresponds to using &lt;code&gt;prev&lt;/code&gt; on normal local variables but there is a subtle difference.
External variables may be changed by the environment.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;@[COutput (binding = &amp;quot;PIN_7&amp;quot;, header = &amp;quot;head.h&amp;quot;)]
extern var isButtonPressed: bool
isButtonPressed = true
await cond // some boolean condition
var x = prev isButtonPressed // is x == true?
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;If &lt;code&gt;cond&lt;/code&gt; is true immediately in the next reaction then x will be set to &lt;code&gt;true&lt;/code&gt;.
In general, however we do not know how many reaction it will take until &lt;code&gt;cond&lt;/code&gt; becomes true.
Yet in every reaction the copy-in and copy-out mechanisms will update the &lt;code&gt;isButtonPressed&lt;/code&gt; buffer.
If the environment does not change &lt;code&gt;PIN_7&lt;/code&gt; then surely &lt;code&gt;x&lt;/code&gt; will be &lt;code&gt;true&lt;/code&gt;.
But, in general, we cannot assume this.&lt;/p&gt;
&lt;p&gt;An activity that declares a mutable external variable automatically becomes a singleton.
Concurrent instances lead to a write-write conflict and compilation is rejected.&lt;/p&gt;
&lt;h3 id=&#34;external-functions&#34;&gt;External functions&lt;/h3&gt;
&lt;p&gt;There are two ways to link to external functions in Blech.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Via direct binding to function name declared in an .h file&lt;/li&gt;
&lt;li&gt;Via a wrapper to be implemented in some .c file.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;In the first case we annotate the name of the C function and the file wherein this function is declared.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;@[CFunction (binding = &amp;quot;ceil&amp;quot;, header = &amp;quot;math.h&amp;quot;)]
extern function ceiling(i: float64) returns float64
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Inside the Blech program this function is now available through name &lt;code&gt;ceiling&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;In the second case we annotate which file we intend to implement the C function in.
Actually this information is irrelevant for the Blech compilation itself.
However, it may become useful in the future once a build system can make sense of these annotations and automatically detect which files are required for the compilation of the whole project.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;extern function myCFunction(i: float64) returns float64
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Assume the above declaration is written in a Blech file called &lt;code&gt;MyFile.blc&lt;/code&gt;, then the code generator will produce a header file &lt;code&gt;MyFile.h&lt;/code&gt; with the following code:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;// extern functions to be implemented in C
&lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;blc_float64&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;blc_MyFile_myCFunction&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;blc_float64&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;blc_i&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;It is up to the C programmer now to include this header in his implementation and provide an actual definition of this function.&lt;/p&gt;
&lt;h3 id=&#34;remarks-on-caveats-when-interfacing-with-c&#34;&gt;Remarks on caveats when interfacing with C&lt;/h3&gt;
&lt;h4 id=&#34;types&#34;&gt;Types&lt;/h4&gt;
&lt;p&gt;Blech has no representation of C types. It requires that the C implementation matches the Blech types. This is usually straightforward for simple types. If there is no one-to-one correspondence between types a wrapper has to be implemented in C that marshals the data between Blech and the actual C function to be called.&lt;/p&gt;
&lt;h4 id=&#34;parameter-lists&#34;&gt;Parameter lists&lt;/h4&gt;
&lt;p&gt;In Blech, functions have two parameter lists as explained above.
The Blech compiler ensures that inputs will only be read.
However the Blech compiler has no chance to check that the external code adheres to this contract.&lt;/p&gt;
&lt;p&gt;For example, say we have an external function that takes an array of length 10 and sorts it in-place.
The correct binding would look something like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;@[CFunction (binding = &amp;quot;sort&amp;quot;, header = &amp;quot;utils.h&amp;quot;)]
extern function sort()(arr: [10]int32)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;In this way, the Blech compiler knows that &lt;code&gt;sort&lt;/code&gt; will modify the given array. When calling this function in a concurrent context the compiler will prevent write-write conflicts and read-write cycles on the array.&lt;/p&gt;
&lt;p&gt;However, the programmer could erroneously declare the same function as follows:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;@[CFunction (binding = &amp;quot;sort&amp;quot;, header = &amp;quot;utils.h&amp;quot;)]
extern function sort(arr: [10]int32)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The code will compile all the same but the causality guarantees are gone because the Blech compiler relies on the assumption that the array will only be read and not modified. At runtime the program may then exhibit unexpected behaviour.&lt;/p&gt;
&lt;h4 id=&#34;singletons&#34;&gt;Singletons&lt;/h4&gt;
&lt;p&gt;The &lt;code&gt;singleton&lt;/code&gt; annotation is a help to the Blech programmer but does not completely prevent concurrent calls to functions with conflicting effects. For example:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;@[CFunction (binding = &amp;quot;foo&amp;quot;, header = &amp;quot;head.h&amp;quot;)]
extern singleton function doA() 
@[CFunction (binding = &amp;quot;foo&amp;quot;, header = &amp;quot;head.h&amp;quot;)]
extern singleton function doB() 

/* ... somewhere in an acitivity scope ... */
cobegin
   doA()
with
   doB()
end
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This example is a valid Blech program because two different singleton functions are called. This is allowed. However the annotation points to the same C function which is obviously a problem. While a linter could in principle check for this &lt;em&gt;particular&lt;/em&gt; mistake there are many more possibilities to specify bindings to functions which will have conflicting effects when called concurrently.
It is up to the programmer to know what are the effects of the external functions to be called and to avoid scenarios such as the one above.&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: Old proposals</title>
      <link>https://boschresearch.github.io/blech-doc/docs/language-evolution/old/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://boschresearch.github.io/blech-doc/docs/language-evolution/old/</guid>
      <description>
        
        
        &lt;h2 id=&#34;accessing-the-blech-environment&#34;&gt;Accessing the Blech environment&lt;/h2&gt;
&lt;h3 id=&#34;environment-variables&#34;&gt;Environment variables&lt;/h3&gt;
&lt;p&gt;Environment variables are either read-only inputs or read-write outputs.
Every environment variables has a counterpart in the Blech environment.
Therefore, they are annotated as &lt;code&gt;@[CInput ...]&lt;/code&gt; or &lt;code&gt;@[COutput ...]&lt;/code&gt;.
Environment variables are classified by the keyword &lt;code&gt;extern&lt;/code&gt;.
A &lt;code&gt;extern let&lt;/code&gt; definition must be annotated with a &lt;code&gt;@[CInput ...]&lt;/code&gt;.
An &lt;code&gt;extern var&lt;/code&gt; definition must be annotated with a &lt;code&gt;@[COutput ...]&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;@[CInput (binding = &amp;quot;theSensor&amp;quot;, header = &amp;quot;sensors.h&amp;quot;)]
extern let sensor: uint8 

@[COutput (binding = &amp;quot;spiIsReady&amp;quot;, header = &amp;quot;spi.h&amp;quot;)]
extern var spiReady: bool
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Since the external C variables bound to the environment variables live in the environment they do not follow the synchronous semantics.
They might be &lt;code&gt;volatile&lt;/code&gt; changing their value during a reaction.
They might be read or written asynchronously by the environment.&lt;/p&gt;
&lt;p&gt;In order to synchronize these C variables, the Blech program holds a buffered value of the external value in the environment variable.&lt;/p&gt;
&lt;p&gt;The Blech runtime system takes care of the synchronisation.
Before the reaction, the values of all external C variables are copied into the environment variable.
After the reaction, the values of the &lt;code&gt;extern var&lt;/code&gt; variables are copied into the external C variables.&lt;/p&gt;
&lt;p&gt;The implementation is allowed to distribute these copying operations into the code generated for each activity, that defines &lt;code&gt;extern&lt;/code&gt; variables.&lt;/p&gt;
&lt;p&gt;Environment variables can only be declared in an &lt;code&gt;activity&lt;/code&gt;.
Functions can only access environment variables via the parameter list.&lt;/p&gt;
&lt;h3 id=&#34;external-read-write-c-variables-are-singletons&#34;&gt;External read-write C variables are singletons&lt;/h3&gt;
&lt;p&gt;An external C variable is a global variable, which is in danger to be accessed concurrently via the environment variable.
While Blech in general prevents this danger by not allowing the declaration of global variables at all, it needs more effort to guarantee this for external C variables.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;activity handleCVariables()
    
    @[CInput (binding = &amp;quot;theSensor&amp;quot;, header = &amp;quot;sensors.h&amp;quot;)]
    extern let sensor: uint8
    @[COutput (binding = &amp;quot;spiIsReady&amp;quot;, header = &amp;quot;spi.h&amp;quot;)]
    extern var spiReady: bool

    repeat
        if sensor &amp;gt; 10 then
            spiReady = true
        end
        await true
    end
end
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;In order to comply to the single-writer principle, declaring an &lt;code&gt;extern var&lt;/code&gt; variable in an activity restricts this activity to be instantiated only once.
The declared variable is a &lt;code&gt;singleton&lt;/code&gt; and does not allow multiple instances.
An activity that declares a singleton cannot be called concurrently, but only sequentially.
Note that this is only necessary for &lt;code&gt;extern var&lt;/code&gt; declarations.
An &lt;code&gt;extern let&lt;/code&gt; variable is &lt;em&gt;not&lt;/em&gt; a &lt;code&gt;singleton&lt;/code&gt;.
Different instances of such an activity can have separate buffers of the external C variable, which might have different values in the same reaction if the external C variable is &lt;code&gt;volatile&lt;/code&gt;.
It is the responsibility of the programmer not to share external C variables in different &lt;code&gt;extern var&lt;/code&gt; declarations.
Two or more &lt;code&gt;extern let&lt;/code&gt; declarations are allowed to have the same annotation &lt;code&gt;@[CInput ...]&lt;/code&gt;.&lt;/p&gt;
&lt;h3 id=&#34;singletons-and-separate-compilation&#34;&gt;Singletons and separate compilation&lt;/h3&gt;
&lt;p&gt;If a module exports an activity that contains a singleton, the signature needs to reflect this in order to enable a correct causality analysis.
The signature for the above activity &lt;code&gt;handleCVariables&lt;/code&gt; looks like the following&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;singleton handleCVariables.spiReady 
activity handleCVariables()
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;It shows the activities prototype, exposes the unique names of the singletons and shows their annotations.
Showing the annotations allows to check the binding to C variables also for modules where the implementation is hidden.&lt;/p&gt;
&lt;h3 id=&#34;the-diamond-call-problem&#34;&gt;The diamond call problem&lt;/h3&gt;
&lt;p&gt;If an activity declares a singleton, it still can be called from several activities.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;activity firstUsage()
    run handleCVariables()
end

activity secondUsage()
    run handleCVariables()
end
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Again &lt;code&gt;firstUsage&lt;/code&gt; and &lt;code&gt;secondUsage&lt;/code&gt; can not be called concurrently.&lt;/p&gt;
&lt;p&gt;In order to check this via the signature, the calling activities, inherits the singletons from the called activity.
In a module signature these activities occur as follows&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;singleton handleCVariables.spiReady
activity firstUsage()

singleton handleCVariables.spiReady
activity secondUsage()

&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;If we combine activities with different singletons, they must not be called concurrently, if they share common singletons.
For example assume the following module signature.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;signature Module 

singleton handleOtherCVariable.theExternVar
activity handleOtherCVariable()
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;A calling activity might inherit all singletons&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;import Module

activity thirdUsage()
    cobegin
        run handleCVariables()
    with
        run handleOtherCVariable()
    end
end
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The deduced signature is&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;import Module

singleton handleCVariables.spiReady, 
          Module.handleOtherCVariable.theExternVar
activity thirdUsage()
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Activity &lt;code&gt;thirdUsage&lt;/code&gt; cannot be called concurrently to &lt;code&gt;firstUsage&lt;/code&gt; or &lt;code&gt;secondUsage&lt;/code&gt; because their singletons overlap.&lt;/p&gt;
&lt;h3 id=&#34;structured-access-to-external-variables&#34;&gt;Structured access to external variables&lt;/h3&gt;
&lt;p&gt;Environment variables can also be referenced from a &lt;code&gt;struct&lt;/code&gt; type, like normal Blech variables.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;struct MyCVariables
    var x: int32
    let ref sensor: uint8
    var ref spiReady: bool
end
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;activity referToCVariables()
    @[CInput (binding = &amp;quot;theSensor&amp;quot;, header = &amp;quot;sensors.h&amp;quot;)]
    extern let sensor: uint8 

    @[COutput (binding = &amp;quot;spiIsReady&amp;quot;, header = &amp;quot;spi.h&amp;quot;)]
    extern var spiReady: bool

    var mcvs: MyCVariables = { x = 0, sensor = sensor, spiReady = spiReady }
end
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;If we use both activities &lt;code&gt;referToCVariables&lt;/code&gt; and &lt;code&gt;handleCVariables&lt;/code&gt; in a Blech program we obviously made a mistake.
Both activities write to the same external C Variable &lt;code&gt;&amp;quot;spiIsReady&amp;quot;&lt;/code&gt;.
The single-writer principle is broken.
The semantics of the program is undefined concerning the environment access.
In general working with externals is unsafe.
In this particular case, it is the responsibility of the programmer to take care, not to share the same &lt;code&gt;COutput&lt;/code&gt; between different &lt;code&gt;extern var&lt;/code&gt; declarations.&lt;/p&gt;
&lt;p&gt;The signatures of both activities cannot reveal this error.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;singleton referToCVariables.spiReady
activity referToCVariables()

singleton handleCVariables.spiReady
activity handleCVariables()
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Idea: It should be the responsibility. of the compiler to collect the environment of a Blech program across all modules in order to allow for a code review supported by such a description file.&lt;/p&gt;
&lt;p&gt;Hints: &lt;code&gt;extern var&lt;/code&gt; and &lt;code&gt;extern let&lt;/code&gt; declarations cannot be declared inside functions.
Use &lt;code&gt;extern let&lt;/code&gt; declarations when possible in order to prevent the propagation of the singletons.&lt;/p&gt;
&lt;p&gt;Since signatures are deduced by the compiler, the whole checking of singletons and the generation of appropriate signatures is done by the compiler.&lt;/p&gt;
&lt;p&gt;Note: A conventional embedded program is full of singletons, not only created by &lt;code&gt;extern var&lt;/code&gt; declarations, but especially by global variables.
In order to maintain the single-writer principle by programming discipline it is almost inevitable, that all functions are only called once in a task list. This makes reuse and testing extremely difficult. Only the rather small number of services is reusable and rather easily testable.&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: Types</title>
      <link>https://boschresearch.github.io/blech-doc/docs/user-manual/types/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://boschresearch.github.io/blech-doc/docs/user-manual/types/</guid>
      <description>
        
        
        &lt;p&gt;A &lt;em&gt;type&lt;/em&gt; defines a &lt;em&gt;domain&lt;/em&gt; &amp;ndash; a set of &lt;em&gt;values&lt;/em&gt; &amp;ndash; a &lt;em&gt;representation&lt;/em&gt; for those values and a set of &lt;em&gt;operations&lt;/em&gt; on those values.&lt;/p&gt;
&lt;p&gt;Often the domains overlap between types.
Also operations may be overloaded for multiple types.
This provides the programmer with some versatility:&lt;/p&gt;
&lt;p&gt;For example, signed integers and unsigned integers share some interval in which calculations may be carried out and interpreted as either one.
Another example is that operations such as addition may have different implementations depending on type (and machine architecture): addition of 16-bit unsigned integers on a 16-bit machine invokes a different set of machine instructions than addition of 32-bit unsigned integers on that same machine.
Yet the same symbol &lt;code&gt;+&lt;/code&gt; denotes both computations in program text.
The same operator also covers additions of numbers for a completely different domain such as floats.&lt;/p&gt;
&lt;p&gt;This versatility comes at a price: the programmer has to pay attention to value ranges, make representation changes explicit and make sure that a unique implementation of an operation (such as &lt;code&gt;+&lt;/code&gt;) can be selected by the compiler.&lt;/p&gt;
&lt;p&gt;Blech is a type safe language which assists the programmer with a powerful type checker that prevents most type related errors at compile time.
It enforces type annotations and explicit casts whenever the type of an expression is not obvious or when a representation needs to be changed before the expression fits the context of an operation.&lt;/p&gt;
&lt;p&gt;The following sections precisely describe which types exist, what their domains and representations are, which operations they define and which types may be combined or transformed into one another.&lt;/p&gt;
&lt;h2 id=&#34;boolean-type&#34;&gt;Boolean type&lt;/h2&gt;
&lt;p&gt;Blech distinguishes a &lt;code&gt;bool&lt;/code&gt; type with two values: &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt;.
Boolean values may be combined using the binary &lt;code&gt;and&lt;/code&gt; and &lt;code&gt;or&lt;/code&gt; operators.
A boolean value is inverted by the unary &lt;code&gt;not&lt;/code&gt; operator.
All comparisons are admissible.
Expressions which evaluate to a boolean value are called &lt;em&gt;conditions&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;In Blech, it is required that conditions that determine the control flow must be side-effect free.
For example, the statements &lt;code&gt;await&lt;/code&gt;, &lt;code&gt;abort&lt;/code&gt;, &lt;code&gt;reset&lt;/code&gt;, &lt;code&gt;repeat..until&lt;/code&gt;, &lt;code&gt;while&lt;/code&gt;, &lt;code&gt;if&lt;/code&gt; all require side-effect free conditions.
The reason is that the evaluation of a condition should not change the program&amp;rsquo;s state.
It would contradict the synchronous semantics if a program&amp;rsquo;s state changed although no reaction was performed in case an &lt;code&gt;await&lt;/code&gt; condition evaluated to &lt;code&gt;false&lt;/code&gt;.
The same reasoning applies to other synchronous control flow statements such as &lt;code&gt;abort&lt;/code&gt; and &lt;code&gt;reset&lt;/code&gt;.
Other imperative control flow statements such as loops or the &lt;code&gt;if&lt;/code&gt; statement follow the same logic for consistency and clarity of the program text.&lt;/p&gt;
&lt;h2 id=&#34;integer-types&#34;&gt;Integer types&lt;/h2&gt;
&lt;p&gt;Integer types are divided into three categories: natural numbers, signed integer numbers and &amp;ldquo;bits&amp;rdquo;.
Each one exist in four sizes that indicate the number of bits needed in a machine to represent a value of this type: 8, 16, 32, 64.&lt;/p&gt;
&lt;p&gt;.Integer types
[cols=&amp;quot;2*&amp;quot;,grid=rows]
|===
| &lt;code&gt;nat8&lt;/code&gt;, &lt;code&gt;nat16&lt;/code&gt;, &lt;code&gt;nat32&lt;/code&gt;, &lt;code&gt;nat64&lt;/code&gt; | Natural numbers
| &lt;code&gt;int8&lt;/code&gt;, &lt;code&gt;int16&lt;/code&gt;, &lt;code&gt;int32&lt;/code&gt;, &lt;code&gt;int64&lt;/code&gt; | Signed integer numbers
| &lt;code&gt;bits8&lt;/code&gt;, &lt;code&gt;bits16&lt;/code&gt;, &lt;code&gt;bits32&lt;/code&gt;, &lt;code&gt;bits64&lt;/code&gt; | Bits
|===&lt;/p&gt;
&lt;p&gt;The distinction of three integral types has the following motivation.
As usual, we would like to distinguish non-negative numbers of the length &lt;code&gt;N&lt;/code&gt; with a range of &lt;code&gt;0&lt;/code&gt; to &lt;code&gt;2^N -1&lt;/code&gt; from integer numbers centred around 0 with a range of &lt;code&gt;2^(N-1)&lt;/code&gt; to &lt;code&gt;2^(N-1) -1&lt;/code&gt;.
However, by design, the operations on both kinds of numbers prohibit overflows.Computations must stay within the representable domain.
Depending on the build mode an overflow causes the program to crash or to mitigate it using saturation arithmetic.
In order to allow writing algorithms that do rely on overflowing non-negative integers as in C, as well as bit-masking and bit-shifting the &lt;code&gt;bitsX&lt;/code&gt; type is introduced.
The bits type of length &lt;code&gt;N&lt;/code&gt; have the same value range as the natural numbers of the same length.&lt;/p&gt;
&lt;p&gt;It is possible to cast between all three types without information loss so long as the size remains unchanged.&lt;/p&gt;
&lt;p&gt;All integral types types admit all arithmetic and comparison operators.
The &lt;code&gt;bitsX&lt;/code&gt; types additionally admit bitwise operations.&lt;/p&gt;
&lt;h2 id=&#34;floating-point-types&#34;&gt;Floating-point types&lt;/h2&gt;
&lt;p&gt;Blech provides the two most commonly used floating point types &lt;code&gt;float32&lt;/code&gt; and &lt;code&gt;float64&lt;/code&gt;.
The language assumes an implementation of these according to IEEE standards.
In the generated code they are mapped to C&amp;rsquo;s &lt;code&gt;float&lt;/code&gt; and &lt;code&gt;double&lt;/code&gt; respectively (see section on &amp;laquo;types:blechconf,blechconf.h&amp;raquo; below).&lt;/p&gt;
&lt;p&gt;Note that the C standard does not guarantee an IEEE compliant implementation of its floating point types nor does it require that &lt;code&gt;float&lt;/code&gt; and &lt;code&gt;double&lt;/code&gt; are distinct types at all.
It is the system integrators responsibility to ensure that the C compiler at hand does fulfil Blech&amp;rsquo;s assumptions.&lt;/p&gt;
&lt;p&gt;Floating point types admit all arithmetic and comparison operators.&lt;/p&gt;
&lt;h2 id=&#34;array-types&#34;&gt;Array types&lt;/h2&gt;
&lt;p&gt;The array data type is parametrised by a fixed &amp;ldquo;shape&amp;rdquo; and a payload data type.
The shape of an array is its dimensionality and length in each dimension.
It is not possible to declare an array data type with an unspecified length.&lt;/p&gt;
&lt;h3 id=&#34;arrays&#34;&gt;Arrays&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;function f(a: [4][5]float32)
    /* ... */
end
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The function &lt;code&gt;f&lt;/code&gt; expects one read-only argument &lt;code&gt;a&lt;/code&gt;.
It is two dimensional array (a table) with 4 rows and 5 columns.
Each cell contains a &lt;code&gt;float32&lt;/code&gt; number.&lt;/p&gt;
&lt;p&gt;Unlike C, in Blech the lengths appear before the payload type in the type declaration.&lt;/p&gt;
&lt;p&gt;Elements of an array are accessed using a subscription operation &lt;code&gt;[]&lt;/code&gt;.
The first element has index &lt;code&gt;0&lt;/code&gt;.
If an array dimension has &lt;code&gt;N&lt;/code&gt; values, the last index is &lt;code&gt;N-1&lt;/code&gt;.
The index argument must be an integer number within array bounds.&lt;/p&gt;
&lt;p&gt;The contents of one array may be copied to another using assignment provided their shape and payload data type are the same.&lt;/p&gt;
&lt;h3 id=&#34;array-operations&#34;&gt;Array operations&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;// Initialise the following matrix
//      cols
// rows 0.0  0.0
//      1.2  3.4
//      0.0  0.0
var a: [3][2]float32 = {[1]={1.2, 3.4}}

let r: [2]float32 = a[1] // copy 2nd row of a into r

let x = a[1][1]          // copy 3.4 to x
                         // x is deduced to have type float32
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;structure-types&#34;&gt;Structure types&lt;/h2&gt;
&lt;p&gt;Structure declarations introduce a new type identifier.
A structure contains a fixed number of &lt;em&gt;fields&lt;/em&gt;.
Each field has an access capability (&lt;code&gt;let&lt;/code&gt; or &lt;code&gt;var&lt;/code&gt;), a name, some data type and possibly a default value initialiser.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-abnf&#34; data-lang=&#34;abnf&#34;&gt;&lt;span style=&#34;color:#000&#34;&gt;StructDeclaration&lt;/span&gt; ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;struct&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Identifier&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Field&lt;/span&gt;+ &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;end&amp;#34;&lt;/span&gt;
&lt;span style=&#34;color:#000&#34;&gt;Field&lt;/span&gt;            ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;&amp;#34;var&amp;#34;&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;let&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Identifier&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;:&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Type&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;&amp;#34;=&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;If an initialiser is given for a field this value is taken as the default value when constructing an instance of this structure.
The initialisation expression must be a compile time value.
Of course, this default value may be overruled by the initialiser given at the instantiation.&lt;/p&gt;
&lt;h3 id=&#34;mutable-and-immutable-structures&#34;&gt;Mutable and immutable structures&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;struct S
   var a: int32 = 7
   var b: int32
end

/* ... somewhere in a local scope ... */
var s1: S    // s1 == {a = 7, b = 0}
s1.b = 17    // ok, now s1 == {a = 7, b = 17}
s1.a = 42    // ok, now s1 == {a = 42, b = 17}
s1 = {}      // ok, reset to default, now s1 == {a = 7, b = 0}

let s2: S = {a = -10, b = 10} // s2 == {a = -10, b = 10}
s2.b = 17                     // error! Cannot change the let variable s2
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Structure &lt;code&gt;s1&lt;/code&gt; is declared using a &lt;code&gt;var&lt;/code&gt; access qualifier.
The fields may be overwritten as well as the structure as a whole.
By contrast, &lt;code&gt;s2&lt;/code&gt; is declared using &lt;code&gt;let&lt;/code&gt;.
It cannot be changed after initialisation.&lt;/p&gt;
&lt;p&gt;The above example illustrates all operations available on structures.
The dot &lt;code&gt;.&lt;/code&gt; is used to access a field value inside a structure.
If the value of a field again is a structure it may be further &amp;ldquo;dotted into&amp;rdquo;.
Structures may be assigned using a struct literal or a name of another struct of the same data type.
Assigning the empty literal &lt;code&gt;{}&lt;/code&gt; means that all default values are restored.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;let&lt;/code&gt; fields cannot be changed once the structure is instantiated.
Assignment on structures as a whole is only permitted if all (sub-)field have &lt;code&gt;var&lt;/code&gt; access qualifiers (and the struct itself has been declared using &lt;code&gt;var&lt;/code&gt;).&lt;/p&gt;
&lt;h3 id=&#34;immutable-fields-in-structures&#34;&gt;Immutable fields in structures&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;struct T
    let a: int32
    var b: int32
end

struct S
    var x: T
    var y: int32
end

/* usage in local scope */
var s: S = {x.a = 7} // ok, s == {x = {a = 7, b = 0}, y = 0}
s.x.b = 42           // ok, s == {x = {a = 7, b = 42}, y = 0}
s = {}               // error! s contains immutable fields
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Assignments to the struct &lt;code&gt;s&lt;/code&gt; are prohibited because &lt;code&gt;s.x.a&lt;/code&gt; is immutable.
You need to individually specify which fields you want to update.
It may be helpful to implement a helper function for this specific data type as shown below.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;function resetS()(s: S)
    s.x.b = 0
    s.y = 0
end

/* usage in local scope */
var s: S
/* ... */
resetS()(s)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;[[types:blechconf]]&lt;/p&gt;
&lt;h2 id=&#34;blechconfh&#34;&gt;blechconf.h&lt;/h2&gt;
&lt;p&gt;Blech compiles to C.
Hence code generation has to map Blech types to C types.
The file &lt;code&gt;blechconf.h&lt;/code&gt; specifies this mapping.
It is automatically included (via &lt;code&gt;blech.h&lt;/code&gt;) in every generated C source file.
The Blech compiler guarantees type safety and correct operational behaviour so long as Blech types are mapped onto C types that fit above representation sizes.
It is up to the system integrator to ensure that this mapping is valid for the C compiler and hardware platform at hand.&lt;/p&gt;
&lt;p&gt;A default mapping that makes sense in most cases is shipped with the compiler:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;#define BLC_VOID void 
&lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;#define BLC_BOOL int 
&lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;#define BLC_INT8 signed char
&lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;#define BLC_INT16 signed short
&lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;#define BLC_INT32 signed long
&lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;#define BLC_INT64 signed long long
&lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;#define BLC_UINT8 unsigned char
&lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;#define BLC_UINT16 unsigned short
&lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;#define BLC_UINT32 unsigned long
&lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;#define BLC_UINT64 unsigned long long
&lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;#define BLC_BITS8 unsigned char
&lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;#define BLC_BITS16 unsigned short
&lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;#define BLC_BITS32 unsigned long
&lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;#define BLC_BITS64 unsigned long long
&lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;#define BLC_FLOAT32 float
&lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;#define BLC_FLOAT64 double
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;However compilers before the C99 standard may not support &lt;code&gt;unsigned long long&lt;/code&gt;, for example.&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: Expressions</title>
      <link>https://boschresearch.github.io/blech-doc/docs/user-manual/expressions/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://boschresearch.github.io/blech-doc/docs/user-manual/expressions/</guid>
      <description>
        
        
        &lt;p&gt;The nomenclature in Blech is similar to that in C.
There are typed memory locations (objects), left hand side expressions (lvalues) and right hand side expressions (rvalues).
Blech does allow to create function references and thus we have no designators.&lt;/p&gt;
&lt;h2 id=&#34;operator-precedence&#34;&gt;Operator precedence&lt;/h2&gt;
&lt;p&gt;The expression grammar below will not specify the precedence of operators.
This allows for a concise presentation.
Therefore this section specifies the precedence separately.&lt;/p&gt;
&lt;p&gt;All operators are left associative in Blech.
The following table summarizes the operator precedence in Blech, from lowest precedence (least binding) to highest precedence (most binding). Operators in the same box have the same precedence. Unless the syntax is explicitly given, operators are binary.&lt;/p&gt;
&lt;p&gt;Operator precedence low to high:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Operators&lt;/th&gt;
&lt;th&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;:&lt;/code&gt;, &lt;code&gt;as&lt;/code&gt;, &lt;code&gt;as!&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Type annotation and type cast&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;or&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Boolean disjunction&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;and&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Boolean conjunction&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;=&lt;/code&gt;, &lt;code&gt;==&lt;/code&gt;, &lt;code&gt;!=&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Comparisons&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;|&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Bitwise OR&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;^&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Bitwise XOR&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;amp;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Bitwise AND&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;lt;&amp;gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;&amp;lt;&amp;gt;&lt;/code&gt;, &lt;code&gt;+&amp;gt;&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Shifts, rotations and signed right shift&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Addition and subtraction&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;*&lt;/code&gt;, &lt;code&gt;/&lt;/code&gt;, &lt;code&gt;+&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Multiplication, division and remainder&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;not&lt;/code&gt; x, &lt;code&gt;-&lt;/code&gt;x, &lt;code&gt;~&lt;/code&gt;x&lt;/td&gt;
&lt;td&gt;Negation, unary minus, bit inversion&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;atoms&#34;&gt;Atoms&lt;/h2&gt;
&lt;p&gt;Atoms are the building blocks of expressions.
They are composed using operators.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-abnf&#34; data-lang=&#34;abnf&#34;&gt;&lt;span style=&#34;color:#000&#34;&gt;Atom&lt;/span&gt; ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Identifier&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;Literal&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;{}&amp;#34;&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;ArrayLiteral&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;StructLiteral&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;ParenthForm&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Note that the term &amp;ldquo;atom&amp;rdquo; is not to be taken too literally because array and structure literals may contain arbitrary expressions themselves.&lt;/p&gt;
&lt;h3 id=&#34;identifiers&#34;&gt;Identifiers&lt;/h3&gt;
&lt;p&gt;An identifier occurring as an atom is a name. See section Identifiers and keywords for lexical definition.&lt;/p&gt;
&lt;h3 id=&#34;literals&#34;&gt;Literals&lt;/h3&gt;
&lt;p&gt;Blech supports various numeric literals:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-abnf&#34; data-lang=&#34;abnf&#34;&gt;&lt;span style=&#34;color:#000&#34;&gt;Literal&lt;/span&gt; ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;BoolLiteral&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;Integer&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;FloatNumber&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Evaluation of a literal yields an object of the given type (bytes, natural number, signed integer, floating point number) with the given value.
The value may be approximated in the case of floating point literals.&lt;/p&gt;
&lt;p&gt;Numeric literals are untyped on their own.
This makes their use more flexible and permits writing more generic code.
Of course, before code generation every expression (and thus every literal) must be assigned a type which is the task of the type checker.
This section explains how to use literals and what type errors may happen.&lt;/p&gt;
&lt;p&gt;Literals are assigned a type either explicitly using a &lt;em&gt;type annotation&lt;/em&gt; expression or implicitly when a unique type can be deduced from the context.&lt;/p&gt;
&lt;h4 id=&#34;annotated-literals&#34;&gt;Annotated literals&lt;/h4&gt;
&lt;p&gt;For example, the literal &lt;code&gt;1&lt;/code&gt; could represent a natural number, a signed integer or a byte word of some size. It could even be a floating point number.
It can be explicitly annotated using a type annotation.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;1: nat16    // 2 bytes long natural number
1: int8     // 1 byte signed integer
1: bits32   // 4 bytes long word
1: float32  // single precision floating point number
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;====&lt;/p&gt;
&lt;p&gt;The lexical analysis of &lt;code&gt;Literal&lt;/code&gt; above suggests there are three kinds of literals.
In fact, we distinguish two kinds of integers.
Binary, octal and hexadecimal integer literals form the group of &lt;em&gt;bits literals&lt;/em&gt;.
They may be interpreted as a byte word of some length or as a natural number of some length.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;0xFF: nat32    // 4 byte natural number with value 255
0b101: bit8    // 1 byte word with value 5
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;They cannot be treated as a signed integer because depending on the length and the machine&amp;rsquo;s representation of negative numbers they might yield a negative or positive value.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;0xFF: int8    // error! Would be -1 if represented in two&#39;s complement
0xFF: int16   // error! Would be 255 in a two byte word
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Also, bits literals cannot be interpreted as floating point numbers.
For the exact specification of floating point numbers a hexadecimal float literal will be introduced.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Decimal integers&lt;/em&gt; may be interpreted as any kind of numeric type as long as the value fits the domain. The example above shows the straightforward use case with the literal &lt;code&gt;1&lt;/code&gt;. Below some corner cases are exemplified:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;-2: nat16     // error! Outside range of natural numbers
-200: int8    // error! Outside range [-128..127]
-2: bits8     // 1 byte word with value 254
-200: float32 // single precision floating point number
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Float literals may only be interpreted as either single or double precision floating point numbers even if their fraction part is zero as in &lt;code&gt;10.0&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;In summary: annotations may only be used where they do not change the value of the expression and the value fits into the domain of the type.&lt;/p&gt;
&lt;h4 id=&#34;type-deduction-for-literals&#34;&gt;Type deduction for literals&lt;/h4&gt;
&lt;p&gt;When a literal occurs as part of a binary expression where one side is already fully typed, the literal&amp;rsquo;s type may be automatically deduced.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;
&lt;table style=&#34;border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;&#34;&gt;&lt;tr&gt;&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;&#34;&gt;
&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;1
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;;width:100%&#34;&gt;
&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-txt&#34; data-lang=&#34;txt&#34;&gt;var a: int32 = 9
let b = a + 17    
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;In line 1, the 9 is deduced to have type &lt;code&gt;int32&lt;/code&gt; because the left hand side is already typed.
Note that a bits literal cannot be used to initialise an integer for reasons explained &amp;laquo;expr:bitsliterals,above&amp;raquo;.&lt;/p&gt;
&lt;p&gt;In line 2, the literal &lt;code&gt;17&lt;/code&gt; is deduced to be &lt;code&gt;int32&lt;/code&gt;, then a signed 32-bit addition is performed and &lt;code&gt;b&lt;/code&gt; is also deduced to be an &lt;code&gt;int32&lt;/code&gt;.&lt;/p&gt;
&lt;h3 id=&#34;complex-literals&#34;&gt;Complex literals&lt;/h3&gt;
&lt;h4 id=&#34;reset-literal&#34;&gt;Reset literal&lt;/h4&gt;
&lt;p&gt;Empty braces &lt;code&gt;{}&lt;/code&gt; have a special meaning.
They represent the default value for any struct or literal.
Using the reset literal in a declaration has the same effect as leaving out the initialisation:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;var x: [8]float32 = {}
var y: [8]float32
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Both &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; will be initialised with zeros in all cells.
The reset literal, as the name suggests, is most useful to set a modified data structure back to its default values:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;var x: [8]float32 = {1, 2, 3, 4, 5, 6, 7, 8}
x = {}    // now x == {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The reset literal cannot be assigned to a structure that contains immutable fields (or, recursively, substructures with immutable fields).
The same is true for arrays with struct payloads.
See the section on &amp;laquo;types:struct,struct types&amp;raquo; for more details.&lt;/p&gt;
&lt;h4 id=&#34;array-literals&#34;&gt;Array literals&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-abnf&#34; data-lang=&#34;abnf&#34;&gt;&lt;span style=&#34;color:#000&#34;&gt;ArrayLiteral&lt;/span&gt; ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;{&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;CellInit&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;&amp;#34;,&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;CellInit&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;}&amp;#34;&lt;/span&gt;
&lt;span style=&#34;color:#000&#34;&gt;CellInit&lt;/span&gt;     ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;IndexExpr&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;=&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt;
&lt;span style=&#34;color:#000&#34;&gt;IndexExpr&lt;/span&gt;    ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;[&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;]&amp;#34;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The array literal has to fit the shape of the array it is assigned to.
That is, the &lt;code&gt;Expr&lt;/code&gt; in &lt;code&gt;IndexExpr&lt;/code&gt; must evaluate to a non-negative number within array bounds.
It is however permitted to specify fewer values than the number given by the array dimensions.
The missing values are implicitly set to the data type&amp;rsquo;s default value.
It is possible to set specific array cells by also specifying an index for a value.
Subsequent unindexed values will be set for the next array cells in order.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;Expr&lt;/code&gt; in &lt;code&gt;CellInit&lt;/code&gt; must match the array&amp;rsquo;s data type.&lt;/p&gt;
&lt;h5 id=&#34;example-setting-array-values&#34;&gt;Example: Setting array values&lt;/h5&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;var x: [2][3]nat8 = {{1, 2, 3},{4, 5, 6}} // all explicit
// x is
// 1  2  3
// 4  5  6

x[1] = {7, 8}                             // third value implicitly 0
// x is
// 1  2  3
// 7  8  0

x[1] = {[1] = 9, 10}                      // first value implicitly 0
// x is                                   // the index of `10` implicitly 2
// 1  2  3
// 0  9  10

x = {{[1] = 11},{[0] = 12, [2] = 13}}
// x is
// 0  11  0
// 12  0  13

x = { {[2]=14} }                          // second row implicitly zeroed out
// x is
// 0  0  14
// 0  0  0
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;struct-literals&#34;&gt;Struct literals&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-abnf&#34; data-lang=&#34;abnf&#34;&gt;&lt;span style=&#34;color:#000&#34;&gt;StructLiteral&lt;/span&gt; ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;{&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;FieldInit&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;&amp;#34;,&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;FieldInit&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;}&amp;#34;&lt;/span&gt;
&lt;span style=&#34;color:#000&#34;&gt;FieldInit&lt;/span&gt;     ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Identifier&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;=&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The identifiers must match the field names of the struct to be assigned.
The &lt;code&gt;Expr&lt;/code&gt; must match the corresponding field&amp;rsquo;s data type.
Immutable (&lt;code&gt;let&lt;/code&gt; declared) fields may only be set in the initialisation of the structure.
Fields that are not specified in the literal are implicitly set to their data type&amp;rsquo;s default value.&lt;/p&gt;
&lt;h5 id=&#34;example-setting-struct-values&#34;&gt;Example: Setting struct values&lt;/h5&gt;
&lt;p&gt;Assume the following declarations:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;struct S
    var a: int8
    var b: int8
end

struct T
    let x: bool
    var y: S
end
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The following code may be written (in some local scope):&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;var t: T = {x = true, y = {a = 1, b = 2}}
// t is
// t.x == true
// t.y.a == 1
// t.y.b == 2

t = {y = {a = 7}} // error! Cannot assign immutable field t.x

t.y = {a = 7}     // implicitly b = 0
// t is
// t.x == true
// t.y.a == 7
// t.y.b == 0
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;parenthesised-form&#34;&gt;Parenthesised form&lt;/h2&gt;
&lt;p&gt;A parenthesised form is an expression enclosed in parentheses:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-abnf&#34; data-lang=&#34;abnf&#34;&gt;&lt;span style=&#34;color:#000&#34;&gt;ParenthForm&lt;/span&gt; ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;  &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;(&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;)&amp;#34;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;A parenthesised expression yields whatever that expression yields.&lt;/p&gt;
&lt;h2 id=&#34;primaries&#34;&gt;Primaries&lt;/h2&gt;
&lt;p&gt;Primaries represent the most tightly bound operations of the language. Their syntax is:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-abnf&#34; data-lang=&#34;abnf&#34;&gt;&lt;span style=&#34;color:#000&#34;&gt;Primary&lt;/span&gt; ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;  &lt;span style=&#34;color:#000&#34;&gt;Atom&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;Selection&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;Subscription&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;FunctionCallExpr&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;field-selection&#34;&gt;Field selection&lt;/h2&gt;
&lt;p&gt;A field selection is a primary expression followed by a period and a name:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-abnf&#34; data-lang=&#34;abnf&#34;&gt;&lt;span style=&#34;color:#000&#34;&gt;Selection&lt;/span&gt; ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;  &lt;span style=&#34;color:#000&#34;&gt;Primary&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;.&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Identifier&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;Primary&lt;/code&gt; must evaluate to a struct instance that contains a field with the name given by &lt;code&gt;Identifier&lt;/code&gt;.&lt;/p&gt;
&lt;h2 id=&#34;subscriptions&#34;&gt;Subscriptions&lt;/h2&gt;
&lt;p&gt;A subscripting expression selects an item of an array:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-abnf&#34; data-lang=&#34;abnf&#34;&gt;&lt;span style=&#34;color:#000&#34;&gt;Subscription&lt;/span&gt; ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;  &lt;span style=&#34;color:#000&#34;&gt;Primary&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;[&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Expression&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;]&amp;#34;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The index expression must return a value that is non-negative an smaller than the array length.
Otherwise the program will crash in debug build mode and saturate to array index bounds in release mode.&lt;/p&gt;
&lt;p&gt;[IMPORTANT]
The current implementation relies on C semantics and has no build modes. It will not necessarily crash, since C may read any addressable memory.&lt;/p&gt;
&lt;h2 id=&#34;calls&#34;&gt;Calls&lt;/h2&gt;
&lt;p&gt;A call calls a function with a possibly empty series of arguments:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-abnf&#34; data-lang=&#34;abnf&#34;&gt;&lt;span style=&#34;color:#000&#34;&gt;FunctionCallExpr&lt;/span&gt; ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Identifier&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;RhsArgList&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;LhsArgList&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;[IMPORTANT]
TODO: Currently the Rhs/LhsArgLists are defined in controlflow.adoc. Restructure?!&lt;/p&gt;
&lt;h2 id=&#34;all-computation-expressions&#34;&gt;All computation expressions&lt;/h2&gt;
&lt;p&gt;All expressions above are concerned with retrieving a single value from some data structure. (With the exception of function calls).
Now all expressions are presented which take a value (or two) and produce a new value from it (those).
The following rule gives an overview of the remaining expression syntax.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-abnf&#34; data-lang=&#34;abnf&#34;&gt;&lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt; ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;
    &lt;span style=&#34;color:#000&#34;&gt;Primary&lt;/span&gt;                                            &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;highest&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;precedence&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt; 
    | &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;-&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;~&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;not&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt;
    | &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;*&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;/&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;%&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt;
    | &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;+&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;-&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt;
    | &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;&amp;gt;&amp;gt;&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;&amp;lt;&amp;lt;&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;&amp;lt;&amp;gt;&amp;gt;&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;&amp;lt;&amp;lt;&amp;gt;&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;+&amp;gt;&amp;gt;&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt;
    | &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;&amp;amp;&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt;
    | &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;^&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt;
    | &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;|&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt;
    | &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;&amp;lt;&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;&amp;gt;&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;&amp;lt;=&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;&amp;gt;=&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;==&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;!=&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt;
    | &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;and&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt;
    | &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;or&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt;
    | &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;:&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Type&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;as&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Type&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;as!&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Type&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;lowest&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;precedence&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Operator precedence has been discussed &amp;laquo;expr:precedence,above&amp;raquo;.&lt;/p&gt;
&lt;h3 id=&#34;unary-operations&#34;&gt;Unary operations&lt;/h3&gt;
&lt;p&gt;The unary &lt;code&gt;-&lt;/code&gt; (minus) operator yields the negation of its numeric argument.
If the argument is a literal without an annotation, it may not be a binary, octal or hexadecimal number because these are supposed to be some &lt;code&gt;bitX&lt;/code&gt; type without a known length (yet) and the result of a minus cannot be defined.&lt;/p&gt;
&lt;p&gt;The unary &lt;code&gt;~&lt;/code&gt; (invert) operator yields the bitwise inversion of its &lt;code&gt;bitsX&lt;/code&gt; argument.
It cannot be applied to a literal without a type annotation.&lt;/p&gt;
&lt;p&gt;The unary &lt;code&gt;not&lt;/code&gt; operator yields the opposite of its Boolean argument.&lt;/p&gt;
&lt;h3 id=&#34;binary-arithmetic-operations&#34;&gt;Binary arithmetic operations&lt;/h3&gt;
&lt;p&gt;The binary arithmetic operations require that the arguments are of some numeric type.&lt;/p&gt;
&lt;p&gt;The arithmetic operations work as expected on all arithmetic types.
See the sections on &amp;laquo;types:arithmetic,arithmetic types&amp;raquo; for details regarding overflow handling.&lt;/p&gt;
&lt;p&gt;The arguments&amp;rsquo; types may differ only in size.
When they differ, the smaller size value is lifted implicitly to the larger size.
The operation is then carried out on (possibly lifted) arguments of the same type.&lt;/p&gt;
&lt;h4 id=&#34;lifting-types&#34;&gt;Lifting types&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;var x: int8 = 7
var y: int16 = 300
var z = x + y
var u = x + 1
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are both signed integers but have different sizes.
In the context of the addition in line 3, the smaller type is lifted to the larger, effectively making &lt;code&gt;x&lt;/code&gt; an &lt;code&gt;int16&lt;/code&gt;.
Then, 16-bit signed addition is carried out producing an &lt;code&gt;int16&lt;/code&gt; typed result.
This result is stored into &lt;code&gt;z&lt;/code&gt; making it a &lt;code&gt;int16&lt;/code&gt; variable, too.&lt;/p&gt;
&lt;p&gt;In line 4, the literal &lt;code&gt;1&lt;/code&gt; is deduced to be of type &lt;code&gt;int8&lt;/code&gt; in the context of this expression (cf. paragraph on &amp;laquo;expr:deduction,type deduction&amp;raquo; for literals).
Then, 8-bit signed addition is carried out producing an &lt;code&gt;int8&lt;/code&gt; typed result.
This result is stored into &lt;code&gt;u&lt;/code&gt; making it a &lt;code&gt;int8&lt;/code&gt; variable, too.&lt;/p&gt;
&lt;p&gt;The following snippet shows typical caveats.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;
&lt;table style=&#34;border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;&#34;&gt;&lt;tr&gt;&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;&#34;&gt;
&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;1
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;2
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;3
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;4
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;5
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;6
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;7
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;;width:100%&#34;&gt;
&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-txt&#34; data-lang=&#34;txt&#34;&gt;var x: int32 = 49 - 7    // error! Cannot determine type of &amp;#39;49&amp;#39; and &amp;#39;7&amp;#39;

var y: int8 = (49: int8) - 128 // error 128 does not fit into int8

var a: bits8 = 0x1
var b: nat8 = 2
var c = a + b            // error! Type mismatch
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;In line 1, the context of &lt;code&gt;49&lt;/code&gt; is &lt;code&gt;7&lt;/code&gt; and vice versa.
Both do not have a concrete type.
It is therefore not clear which implementation of &lt;code&gt;-&lt;/code&gt; should be invoked.
The code only specifies that the result will be stored in an &lt;code&gt;int32&lt;/code&gt; memory location but several different types (&lt;code&gt;int8&lt;/code&gt;, &lt;code&gt;int16&lt;/code&gt;, &lt;code&gt;int32&lt;/code&gt;) would fit in there.&lt;/p&gt;
&lt;p&gt;In line 3, the previous issue was resolved by specifying that &lt;code&gt;49&lt;/code&gt; should be treated as an &lt;code&gt;int8&lt;/code&gt;.
Thus the other operand must be an &lt;code&gt;int8&lt;/code&gt; as well but the given literal is outside the &lt;code&gt;int8&lt;/code&gt; domain.
(In this particular case, writing &lt;code&gt;(49: int8) + (-128)&lt;/code&gt; would solve the problem due to the asymmetry of signed integers.)&lt;/p&gt;
&lt;p&gt;The last line shows on operation on different types (of the same size).
Addition for natural numbers must not overflow while addition for bits will wrap around.
It is not clear which one should be used here.
Either &lt;code&gt;a&lt;/code&gt; or &lt;code&gt;b&lt;/code&gt; need to be explicitly cast using the &lt;code&gt;as&lt;/code&gt; operator to resolve this issue.&lt;/p&gt;
&lt;h3 id=&#34;bitwise-operations&#34;&gt;Bitwise operations&lt;/h3&gt;
&lt;p&gt;// TODO&lt;/p&gt;
&lt;h3 id=&#34;comparison-operations&#34;&gt;Comparison operations&lt;/h3&gt;
&lt;p&gt;Unlike C, in Blech equality and inequality have the same priority as the ordering operators.
Furthermore the precedence of comparison operators is lower than that of any arithmetic, shifting or bitwise operation.&lt;/p&gt;
&lt;p&gt;Note that all operators are left associative.
Hence chaining comparisons is possible syntactically but makes little sense.&lt;/p&gt;
&lt;h4 id=&#34;comparison-chaining&#34;&gt;Comparison chaining&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;var b = 4 &amp;lt; 5 &amp;lt;= false // evaluates to true &amp;lt;= false which is false
var c = 4 &amp;lt; 5 &amp;lt;= 6 // type error: cannot compare true &amp;lt;= 6
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This is different to C because in Blech booleans and numbers are incomparable.&lt;/p&gt;
&lt;h4 id=&#34;comparison-lifting&#34;&gt;Comparison lifting&lt;/h4&gt;
&lt;p&gt;Comparison operators lift their arguments to a common sized type like arithmetic operators do (see above).
Additionally, comparisons permit using literals that would require a larger domain.
This allows writing (in)equalities without cluttering the code with trivial type casts.&lt;/p&gt;
&lt;h5 id=&#34;example-comparison-with-literals-outside-the-domain&#34;&gt;Example: Comparison with literals outside the domain&lt;/h5&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;var x: int8 = 7
var y = x &amp;lt; 1000
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The literal &lt;code&gt;1000&lt;/code&gt; is a (signed) integral number and would fit into an &lt;code&gt;int16&lt;/code&gt;.
Therefore we allow to implicitly lift &lt;code&gt;x&lt;/code&gt; to &lt;code&gt;int16&lt;/code&gt; and carry out the comparison.
This makes sense because the result of all comparison operators is always a Boolean value.
There are no &amp;ldquo;surprises&amp;rdquo; about the outcome.&lt;/p&gt;
&lt;h3 id=&#34;logical-operatorions&#34;&gt;Logical operatorions&lt;/h3&gt;
&lt;p&gt;The operators &lt;code&gt;and&lt;/code&gt; and &lt;code&gt;or&lt;/code&gt; may only be applied to Boolean typed arguments.&lt;/p&gt;
&lt;p&gt;The expression &lt;code&gt;a and b&lt;/code&gt; is true if and only if &lt;code&gt;a&lt;/code&gt; is true and &lt;code&gt;b&lt;/code&gt; is true.
The evaluation is performed lazily: first &lt;code&gt;a&lt;/code&gt; is evaluated. If it is false, the expression returns &lt;code&gt;false&lt;/code&gt; without evaluating &lt;code&gt;b&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The expression &lt;code&gt;a or b&lt;/code&gt; is true unless both &lt;code&gt;a&lt;/code&gt; is false and &lt;code&gt;b&lt;/code&gt; is false.
The evaluation is performed lazily: first &lt;code&gt;a&lt;/code&gt; is evaluated. If it is true, the expression returns &lt;code&gt;true&lt;/code&gt; without evaluating &lt;code&gt;b&lt;/code&gt;.&lt;/p&gt;
&lt;h3 id=&#34;representation-annotation-and-change&#34;&gt;Representation annotation and change&lt;/h3&gt;
&lt;p&gt;Type annotations specify a concrete type for a literal which may represent values from different types.&lt;/p&gt;
&lt;p&gt;Type casts &lt;em&gt;change&lt;/em&gt; the type of an already typed expression.
Casts are only permitted where the (machine) representation of a value will not change and casts assume that the value fits into the target type&amp;rsquo;s domain.&lt;/p&gt;
&lt;h4 id=&#34;safe-casts&#34;&gt;Safe casts&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;var x: int16 = 100
let y = x as nat8    // ok, y == 100 of type nat8

x = x * 3
let z = x as nat8    // runtime error: 300 outside nat8 domain 0..255

x = -256             // assuming 2&#39;s complement on the machine:
                     // x == 0xb_1111_1111_0000_0000
let u = x as bits8   // runtime error
let v = x as bits16  // ok, v == 65280

let f: float = 1
x = f as int16       // error! impossible to cast floating point to integral types
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The restrictions on the casts do not rule out runtime errors.
At the same time they prevent some manipulations that are possible in C.
For example, it is not possible to interpret a floating point as a bits type and change individual bits.&lt;/p&gt;
&lt;p&gt;// TODO is the description of &lt;code&gt;as&lt;/code&gt; correct. Are the restrictions bugs, features?&lt;/p&gt;
&lt;h3 id=&#34;evaluation-order&#34;&gt;Evaluation order&lt;/h3&gt;
&lt;p&gt;Undefined at the moment. Evaluated by the C compiler.&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: </title>
      <link>https://boschresearch.github.io/blech-doc/docs/user-manual/old/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://boschresearch.github.io/blech-doc/docs/user-manual/old/</guid>
      <description>
        
        
        &lt;h1 id=&#34;embedded-realtime-programming&#34;&gt;Embedded realtime programming&lt;/h1&gt;
&lt;h2 id=&#34;user-manual&#34;&gt;User Manual&lt;/h2&gt;
&lt;h3 id=&#34;annotations-pragmas-and-doc-comments&#34;&gt;Annotations, pragmas and doc comments&lt;/h3&gt;
&lt;p&gt;As explained before Blech allows annotations to declarations.
In principle every declaration can have one or more annotations.&lt;/p&gt;
&lt;p&gt;Currently we use annotations for the entry point of a Blech program and for the binding to C implementations.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;@[EntryPoint]
activity ... end

@[CConst(binding=&amp;quot;A_C_CONST&amp;quot;)]
extern const ABlechConst
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;C bindings have an optional header parameter where the necessary header file can be defined.&lt;/p&gt;
&lt;p&gt;In order to prevent repetition we also allow pragmas which are annotations to the current scope.
Pragmas can occur where members or statements are allowed.
Pragmas are similar to annotations but start with &lt;code&gt;@@&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Currently we use pragmas for central C include file definitions in order to prevent repitition of header definitions in annotations.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;@@[CInclude(header=&amp;quot;myheader.h&amp;quot;)]

@[CConst(binding=&amp;quot;A_C_CONST&amp;quot;)]
extern const ABlechConst

@[CConst(binding=&amp;quot;ANOTHER_C_CONST&amp;quot;)]
extern const AnotherBlechConst
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Pragmas can be used in order to define metadata for a whole compilation unit or to give directives to the compiler - valid to the scope where they occur.
Imagine the following - which is currently not implemented.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;@@[Link(lib=&amp;quot;myclib.a&amp;quot;)]

function f(x: int32)
    if x &amp;gt; 10 then
        @@[AllowShadowing]
        var x: float32
        x = 42.0
    end
end
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Annotations also allow to attach doc comments to the abstract syntax tree.
Line doc comments and block doc comments are stored as annotations.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;/// a line doc comment
const myConst = 11

/** 
    a block doc comment
*/
function myDocumentedFunc()
end
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Parsed doc comments allow to reproduce documentation in &lt;code&gt;.blh&lt;/code&gt; signature files and in generated code.&lt;/p&gt;
&lt;h3 id=&#34;blechs-c-interface&#34;&gt;Blech&amp;rsquo;s C interface&lt;/h3&gt;
&lt;p&gt;C can be bound to Blech via annotations.&lt;/p&gt;
&lt;p&gt;In principal every Blech declarable entity can be implemented in C.
Via an annotation a Blech &lt;code&gt;extern&lt;/code&gt; declaration can be bound to a C implementation.
It is the responsibility of the programmer to make sure that the C implementation provides what the Blech definition guarantees.&lt;/p&gt;
&lt;p&gt;Currently we support &lt;code&gt;extern const&lt;/code&gt; and &lt;code&gt;extern function&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;@[CConst(binding = &amp;quot;5 * A_C_CONST&amp;quot;, header = &amp;quot;myconsts.h&amp;quot;)]
extern const blech_const
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;blech_const&lt;/code&gt; is implemented as a C constant.
Assume we have the following macro in &lt;code&gt;myconsts.h&lt;/code&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;#define A_C_CONST 42
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The generated code for the above extern Blech constant is also a macro that requires the include of the appropriate .h-file.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;// C headers for extern declarations
&lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;&amp;#34;myconsts.h&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;// extern Blech constants
&lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;#define blc_blech_const (5 * A_C_CONST)
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;An extern Blech function comes in two flavours.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;ol&gt;
&lt;li&gt;As a direct binding too a C function and its .h-file&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;As a wrapper to be written in C.&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The first case is easy&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;@[CFunction (binding = &amp;quot;ceil&amp;quot;, header = &amp;quot;math.h&amp;quot;)]
extern function ceiling(i: float64) returns float64
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The generated code is again simply a macro.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;// C headers for extern declarations
&lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;&amp;#34;math.h&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;// extern Blech functions
&lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;#define blc_ceiling(blc_i) (ceil(blc_i))
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The second case defines an extern function without a direct C binding.
Assume the following code in a Blech module &lt;code&gt;wrapper.blc&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;extern function myCFunction(i: float64) returns float64
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;In this case only a prototype is generated in the module&amp;rsquo;s header file &lt;code&gt;blech/wrapper.h&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;// extern functions to be implemented in C

blc_float64 blc_wrapper_myCFunction (const blc_float64 blc_i);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The implementation suitable to the generated prototype has to be provided by the programmer.
To guarantee the interface the generated .h-file has to be included.&lt;/p&gt;
&lt;p&gt;Extern declarations could also be used for &lt;code&gt;type, typealias, param, var, let, activity&lt;/code&gt; and will be incrementally added.&lt;/p&gt;
&lt;p&gt;Since Blech does not allow global variables the local usage of &lt;code&gt;extern var&lt;/code&gt; and &lt;code&gt;extern let&lt;/code&gt; creates a &amp;ldquo;static&amp;rdquo; local - in the sense of C - and requires the surrounding subprogram or struct declaration to be classified as a &lt;code&gt;singleton&lt;/code&gt;.
The same should be necessary for activities written in C that only can represent the state from step to step in global variables which make these activities &lt;code&gt;singleton&lt;/code&gt; too.&lt;/p&gt;

      </description>
    </item>
    
  </channel>
</rss>
