<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Blech â€“ Blech language evolution</title>
    <link>https://boschresearch.github.io/blech-doc/docs/language-evolution/</link>
    <description>Recent content in Blech language evolution on Blech</description>
    <generator>Hugo -- gohugo.io</generator>
    
	  <atom:link href="https://boschresearch.github.io/blech-doc/docs/language-evolution/index.xml" rel="self" type="application/rss+xml" />
    
    
      
        
      
    
    
    <item>
      <title>Docs: Borrowing</title>
      <link>https://boschresearch.github.io/blech-doc/docs/language-evolution/borrowing/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://boschresearch.github.io/blech-doc/docs/language-evolution/borrowing/</guid>
      <description>
        
        
        &lt;h2 id=&#34;borrowing-in-rust-and-blech&#34;&gt;Borrowing in Rust and Blech&lt;/h2&gt;
&lt;p&gt;Blech&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;function outIsInPlus1 (a: int32)(b: int32)
    b = 1
    b = a + b 
end

activity main()
    var i = 42: int32
    incr(i)(i) // --&amp;gt; 43
    await true
end
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;A similar program in Rust.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;outIsInPlus1&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;a&lt;/span&gt;: &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;i32&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;b&lt;/span&gt;: &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;mut&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;i32&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;{&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;    &lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;b&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;a&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;main&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;()&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;{}&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;    &lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;let&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;mut&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;i&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;42&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;    &lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;outIsInPlus1&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;i&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;mut&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;i&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;);&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;    &lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;println&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;!&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;{}&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;i&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;);&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;  &lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;// --&amp;gt; 43
&lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;No problem with this. Because the input parameter &lt;code&gt;a&lt;/code&gt; has value/copy semantics.&lt;/p&gt;
&lt;p&gt;Blech automatically takes references and de-references them if necessary. It decides on mutability through the occurence in the input or output parameter list. Semantically the Blech program has the following form:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;function outIsInPlus1(&amp;lt;let&amp;gt; a: int32)(&amp;lt;var ref&amp;gt; b: int32)
    &amp;lt;*&amp;gt; b = 1
    &amp;lt;*&amp;gt; b = &amp;lt;*&amp;gt; a + &amp;lt;*&amp;gt; b 
end

activity main()
    var i = 42: int32
    outIsInPlus1(i)(&amp;lt;&amp;amp;&amp;gt; i) // --&amp;gt; 43
    await true
end
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This is semantically very close to Rust.&lt;/p&gt;
&lt;p&gt;We would change the function in Blech if the input &lt;code&gt;a&lt;/code&gt; should be passed by reference.
Note that references are not implemented in the current compiler.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;function outIsInPlus1(ref a: int32)(b: int32)
    b = 1       // b = 1
    b = a + b   // b = 1 + a
end

activity main()
    var i = 42: int32
    outIsInPlus1(i)(i) // --&amp;gt; 2
    await true
end
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The value of output &lt;code&gt;i&lt;/code&gt; becomes &lt;code&gt;2&lt;/code&gt;, which is not input &lt;code&gt;i&lt;/code&gt; plus &lt;code&gt;1&lt;/code&gt;. For functions in Blech this could be allowed, because they do not contain &lt;code&gt;cobegin&lt;/code&gt;, but it is dangerous and unexpected, especially at the caller side, where you can&amp;rsquo;t see this behaviour by reading the code.&lt;/p&gt;
&lt;p&gt;Rust does not allow this call. The borrow checker detects an error.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;outIsInPlus1&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;a&lt;/span&gt;: &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;i32&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;b&lt;/span&gt;: &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;mut&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;i32&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;{&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;    &lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;b&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;    &lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;b&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;a&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;b&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;main&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;()&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;{&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;    &lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;let&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;mut&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;i&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;42&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;    &lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;outIsInPlus1&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;i&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;mut&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;i&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;);&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-txt&#34; data-lang=&#34;txt&#34;&gt;error[E0502]: cannot borrow `i` as mutable because it is also borrowed as immutable
 --&amp;gt; src/example.rs:9:11
  |
9 |     outIsInPlus1(&amp;amp;i, &amp;amp;mut i);
  |     ------------ --  ^^^^^^ mutable borrow occurs here
  |     |            |
  |     |            immutable borrow occurs here
  |     immutable borrow later used by call

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;This behavior is similar to the use of parameters in Blech activities. Blech does not allow the following &lt;code&gt;run outIsInPlus1(i)(i)&lt;/code&gt; statement. The causality checker detects an error.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;activity outIsInPlus1(a: int32)(b: int32)
    b = 1       // b = 1
    b = a + b   // b = 1 + a
    await true
end

activity main()
    var i = 42: int32
    run outIsInPlus1(i)(i)
    await true
end
&lt;/code&gt;&lt;/pre&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-txt&#34; data-lang=&#34;txt&#34;&gt;error: Read-write conflict. i or an alias thereof occurs both in the input and output list of the sub program call.
  --&amp;gt; example.blc:11:5 [causality]

11 |     run outIsInPlus1(i)(i)
   |                         - Output argument.
11 |     run outIsInPlus1(i)(i)
   |                      ^ Input argument.

  If this usage is intended, consider using the &amp;#34;shares&amp;#34; keyword when declaring the formal parameters of the subprogram.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Blech automatically takes refencences and de-references if necessary. It decides on mutability through the occurence in the input or output parameter list. Input parameters in Blech are semantically passed by-value for functions and passed by-reference for activities. 
Therefore the activity &lt;code&gt;outIsInPlus1&lt;/code&gt; has semantically the following form:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;activity outIsInPlus1(&amp;lt;let ref&amp;gt; a: int32)(&amp;lt;var ref&amp;gt;b: int32)
    &amp;lt;*&amp;gt; b = 1       
    &amp;lt;*&amp;gt; b = &amp;lt;*&amp;gt; a + &amp;lt;*&amp;gt; b
    await true
end

activity main()
    var i = 42: int32
    run outIsInPlus1(&amp;lt;&amp;amp;&amp;gt; i)(&amp;lt;&amp;amp; mut&amp;gt; i)
    await true
end
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Actually the above causality error is almost equivalent to Rust&amp;rsquo;s borrowing error.&lt;/p&gt;
&lt;p&gt;We would argue, that the above function with an input parameter passed by-reference should be marked as an error if called with identical references.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;function outIsInPlus1(ref a: int32)(b: int32)
...
    var i = 42: int32
    outIsInPlus1(i)(i)  // causality error or borrowing error
...
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;If we have more uses for borrowing and a &lt;strong&gt;borrowing checker&lt;/strong&gt; this could become a &lt;strong&gt;borrowing error&lt;/strong&gt; instead of a causality error.&lt;/p&gt;
&lt;h2 id=&#34;borrowing&#34;&gt;Borrowing&lt;/h2&gt;
&lt;p&gt;Passing parameters by-reference is essentially borrowing a reference.&lt;/p&gt;
&lt;p&gt;There are several combinations&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Blech&lt;/th&gt;
&lt;th&gt;Semantics&lt;/th&gt;
&lt;th&gt;Blech call&lt;/th&gt;
&lt;th&gt;Call semantics&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;function f (a: T)&lt;/td&gt;
&lt;td&gt;function f (let a: T)&lt;/td&gt;
&lt;td&gt;f(x)&lt;/td&gt;
&lt;td&gt;f(x)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;function f (ref a: T)&lt;/td&gt;
&lt;td&gt;function f (let ref a: T)&lt;/td&gt;
&lt;td&gt;f(x)&lt;/td&gt;
&lt;td&gt;f(&amp;amp;x)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;function f ()(b: T)&lt;/td&gt;
&lt;td&gt;function f ()(var ref b: T)&lt;/td&gt;
&lt;td&gt;f()(x)&lt;/td&gt;
&lt;td&gt;f()(&amp;amp;x)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;activity a (a: T)&lt;/td&gt;
&lt;td&gt;activity a (let ref a: T)&lt;/td&gt;
&lt;td&gt;run a(x)&lt;/td&gt;
&lt;td&gt;run a(&amp;amp;x)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;activity a ()(b: T)&lt;/td&gt;
&lt;td&gt;activity a ()(var ref b: T)&lt;/td&gt;
&lt;td&gt;run a()(x)&lt;/td&gt;
&lt;td&gt;run a()(&amp;amp;x)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;In case of an input parameter it is a non-mutable borrowing. In case of an output parameter it a mutable borrowing.&lt;/p&gt;
&lt;h2 id=&#34;borrowing-via-reference-declarations&#34;&gt;Borrowing via reference declarations&lt;/h2&gt;
&lt;p&gt;Borrowing not only occurs when passing parameters, but also when declaring references.
We also planned this for Blech.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;activity main()
    var x: int32 = 42
    let ref y = x
    x = y + 1 // x == 43, y == 43 
    await true
end
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This would be a strange behaviour in Blech, when reasoning about this program. Especially since &lt;code&gt;y&lt;/code&gt; is a read-only reference, but changes its value via the assignment. Rust forbids this by the borrow checker.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;main&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;()&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;{&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;    &lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;let&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;mut&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;x&lt;/span&gt;: &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;i32&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;42&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;    &lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;let&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;y&lt;/span&gt;: &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;i32&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;x&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;    &lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;x&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;y&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;    &lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;println&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;!&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;x:{}, y:{}&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;x&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;y&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;);&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-txt&#34; data-lang=&#34;txt&#34;&gt;error[E0506]: cannot assign to `x` because it is borrowed
 --&amp;gt; src/main.rs:4:5
  |
3 |     let y: &amp;amp;i32 = &amp;amp;x;
  |                   -- borrow of `x` occurs here
4 |     x = *y + 1;
  |     ^^^^^^^^^^ assignment to borrowed `x` occurs here
5 |     println!(&amp;#34;x:{}, y:{}&amp;#34;, x, y);
  |                               - borrow later used here
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;In Rust you cannot use &lt;code&gt;x&lt;/code&gt; after it has been non-mutably borrowed to &lt;code&gt;y&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;We propose to adopt the ideas of borrowing from Rust to Blech, in order to benefit from the guarantees the borrow checker gives for your program.&lt;/p&gt;
&lt;h2 id=&#34;behaviour-of-the-borrow-checker&#34;&gt;Behaviour of the borrow checker&lt;/h2&gt;
&lt;p&gt;A good overview of how borrowing restricts the usage of variables and references can be found in a &lt;a href=&#34;https://rufflewind.com/2017-02-15/rust-move-copy-borrow#comments&#34; target=&#34;_blank&#34;&gt;Graphical depiction of ownership and borrowing in Rust&lt;/a&gt;
.&lt;/p&gt;
&lt;p&gt;Move semantics can be neglected for the moment since currently only have value types which all allow copying, which in Rust terminology means, they implement the copy trait. Nevertheless move semantics might become important in for Blech&amp;rsquo;s planned reference types.&lt;/p&gt;
&lt;p&gt;For borrowing it distinguishes between &lt;em&gt;frozen&lt;/em&gt; and &lt;em&gt;locked&lt;/em&gt; behaviour.&lt;/p&gt;
&lt;p&gt;Mutable borrowing, &lt;em&gt;locks&lt;/em&gt; the original object for the duration of the borrow, rendering it unusable.&lt;/p&gt;
&lt;p&gt;Non-mutable borrowing &lt;em&gt;freezes&lt;/em&gt; the original object, you can still take more non-mutable references, but you cannot move or take mutable references of it.&lt;/p&gt;
&lt;h3 id=&#34;non-mutable-borrow-freezes-original-object&#34;&gt;Non-mutable borrow &lt;em&gt;freezes&lt;/em&gt; original object&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;activity main()
    var s: int32 = 42
    do
        let ref r = s  // ok, s is now frozen
        cobegin
            // can non-mutably borrow from r 
            let ref a = r  // ok 
            ...
        with
            // can still &amp;amp;s
            let ref b = s  // ok
            ...
        with
            // cannot &amp;amp;mut s
            var ref c = s // not ok, similar to first example, could read s via r, and write s via c
            ...
        with
            // cannot move s
            // not applicable because s has a value type
            ...
        end
    end
    // all borrows terminated    
    s = s + 1 
    await true
end
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;mutable-borrow-locks-original-object&#34;&gt;Mutable borrow &lt;em&gt;locks&lt;/em&gt; original object&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;activity main()
    var s: int32 = 42
    do
        var ref m = s  // ok, s is locked
        cobegin 
            // can move m
            var ref a = move m // ok, cannot use m anymore, will be discussed later
            ...
        with
            // can downgrade m to read-only
            let ref b = m  // ok, m is now frozen
            ...
        with
            // can borrow mutably from m
            var ref c = m  // ok, m is locked from here
        with
            // cannot copy m
            // not applicable, references are taken and de-referenced implicitly
            ...
        with
            // cannot use s at all, s is locked
            let ref d = s  // not ok
            var ref e = s  // not ok
            let e = s      // not ok
            var e = s      // not ok
            ...
        end
    end
    // all borrows terminated    
    s = s + 1 
    await true
end
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;As shown before, passing parameters can be explained as borrowing&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Passing a parameter to an output list essentially is a borrowing as mutable reference.&lt;/li&gt;
&lt;li&gt;Passing an input parameter in an activity essentially is borrowing as a non-mutable reference.&lt;/li&gt;
&lt;li&gt;Passing an input parameter to a function is copying.&lt;/li&gt;
&lt;li&gt;Passing an input parameter to a formal reference parameter is borrowing.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;As shown here, taking references in various forms can also be explained as borrowing.&lt;/p&gt;
&lt;p&gt;Borrowing has a sequential ordering along the program text.
This could be used to enable multiple concurrent writers for specific memory cells.&lt;/p&gt;
&lt;h2 id=&#34;borrowing-for-sequential-parallel-writes&#34;&gt;Borrowing for sequential parallel writes&lt;/h2&gt;
&lt;p&gt;The merely theorectical &amp;ldquo;sequential-parallel-or&amp;rdquo; operator is dangerous, because it switches off causality analysis completely, for all accesses to memory cells.&lt;/p&gt;
&lt;p&gt;Therefore we propose to enable sequential parallel writes for indivual memory locations.
We could use the sequential ordering of borrowing for this.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;...
    var original: int32
    cobegin
        run controlValue()(original)
    with
        var ref updated = original // mutable borrow
        run updateValue()(updated)
    end
    ...
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;What is the semantics?&lt;/p&gt;
&lt;p&gt;In every step the activity &lt;code&gt;controlValue&lt;/code&gt; writes to &lt;code&gt;original&lt;/code&gt;. We can understand borrowing as a sequential chaining. In every step of the second thread &lt;code&gt;updated&lt;/code&gt; borrows &lt;code&gt;original&lt;/code&gt;, which in turn is updated in every step. &lt;code&gt;original&lt;/code&gt; is locked here and cannot be used. The borrowing defines a sequential write order.&lt;br&gt;
We can regard both blocks of the &lt;code&gt;cobegin&lt;/code&gt; as partially sequentialised.&lt;/p&gt;
&lt;p&gt;Of course we can switch the blocks with the same semantics.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;...
    var original: int32
    cobegin
        var ref updated = original // mutable borrow, original is locked
        run updateValue()(updated)
    with
        run controlValue()(original)
    end
    ...
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The borrowing &lt;code&gt;var ref update = original&lt;/code&gt; defines an &amp;ldquo;update &lt;code&gt;original&lt;/code&gt; from &lt;code&gt;updated&lt;/code&gt; edge&amp;rdquo; for causality analysis. Every writeable location must not have more than 1 incoming update edge.&lt;/p&gt;
&lt;p&gt;Without references and borrowing we need local variables to sequentialise the write accesses in &lt;code&gt;controlValue&lt;/code&gt; and &lt;code&gt;updateValue&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;...
    var original: int32
    var local: int32
    var updated = original
    cobegin
        run controlValue(prev updated)(local)
    with
        run updateValue(local)(updated)
    with 
        repeat
            original = updated
            await true
        end
    end
    ...
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This solution, which is perfectly correct in the current compiler, is adopted from the &lt;a href=&#34;https://github.com/frameworklabs/blinker/blob/master/src/blinker.blc&#34; target=&#34;_blank&#34;&gt;Blech blinker example&lt;/a&gt;
.&lt;/p&gt;
&lt;p&gt;Compared to the first version the second needs 2 additional memory locations, additional parameters to enable the data flow, a loop that copies the result back to &lt;code&gt;original&lt;/code&gt; in every step, and additionally &lt;code&gt;controlValue&lt;/code&gt; and &lt;code&gt;updateValue&lt;/code&gt; need to copy from input to output in every step. As usual the order of &lt;code&gt;cobegin&lt;/code&gt; blocks is irrelevant.&lt;/p&gt;
&lt;p&gt;The version with references and borrowing can reuse the &lt;code&gt;original&lt;/code&gt; memory location based on the statically defined sequential order and needs no additional copying loops.&lt;/p&gt;
&lt;p&gt;Now, what happens if both threads borrow &lt;code&gt;original&lt;/code&gt;?&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;...
    var original: int32
    cobegin
        var ref controlled = original // mutable borrow
        run controlValue()(original)
    with
        var ref updated = original    // mutable borrow
        run updateValue()(updated)
    end
    ...
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The location &lt;code&gt;original&lt;/code&gt; has now 2 incoming update edges from &lt;code&gt;controlled&lt;/code&gt; and &lt;code&gt;updated&lt;/code&gt; which is essentially a write-write conflict in causality analysis.&lt;/p&gt;
&lt;p&gt;The &amp;lsquo;trick&amp;rsquo; of the sequentialisation is scoping of borrowing. If we need 3 concurrent threads that write to the &lt;code&gt;original&lt;/code&gt; memory location, we need to scope borrowing, which nicely shows the sequentialisation.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;...
    var original: int32
    cobegin 
        run initialiseValue()(original)
    with
        var ref controlled = original // mutable borrow
        cobegin
            run controlValue()(controlled)
        with
            var ref updated = controlled // mutable borrow
            run updateValue()(updated)
        end
    end
    ...
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;We have update egdes from  &lt;code&gt;updated&lt;/code&gt; to &lt;code&gt;controlled&lt;/code&gt; and from &lt;code&gt;controlled&lt;/code&gt; to &lt;code&gt;original&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;To make things more interesting we can mix-in causal concurrency.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;...
    var original: int32
    var a: int32
    var b: int32
    cobegin
        run controlValue(a)(b, original)
    with
        var ref updated = original
        run updateValue(b)(a, updated)
    end
    ...
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Here we get a cyclic write-read path on &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;. We can use &lt;code&gt;prev&lt;/code&gt; to break this cycle. Since &lt;code&gt;original&lt;/code&gt; must be written before &lt;code&gt;updated&lt;/code&gt;, this only helps if we apply &lt;code&gt;prev&lt;/code&gt; to the input of activity &lt;code&gt;controlValue&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;...
    var original: int32
    var a: int32
    var b: int32
    cobegin
        run controlValue(prev a)(b, original)
    with
        var ref updated = original // mutable borrowing
        run updateValue(b)(a, updated)
    end
    ...
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Note: Non-mutable borrowing does not imply additional causal constraints. It is simply write before read. But it helps clarifying the program semantics as explained in the introduction.&lt;/p&gt;
&lt;h2 id=&#34;dismiss-shares&#34;&gt;Dismiss &lt;code&gt;shares&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;Blech currently proposes to use a &lt;code&gt;shares&lt;/code&gt; if this an intended behaviour. 
We think this is no longer necessary with borrowing, causality and passing inputs to functions by-reference and by-value.&lt;/p&gt;
&lt;h2 id=&#34;todo&#34;&gt;Todo&lt;/h2&gt;
&lt;h3 id=&#34;borrow-spitting&#34;&gt;Borrow spitting&lt;/h3&gt;
&lt;p&gt;[Spitting borrows]https://doc.rust-lang.org/nomicon/borrow-splitting.html&lt;/p&gt;
&lt;p&gt;Similar to splitting causality analysis. Ok for structs, not possible for arrays.&lt;/p&gt;
&lt;p&gt;Rules for borrow checker like in Rust.&lt;/p&gt;
&lt;h3 id=&#34;the-move-operator&#34;&gt;The &lt;code&gt;move&lt;/code&gt; operator&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://stackoverflow.com/questions/30288782/what-are-move-semantics-in-rust&#34; target=&#34;_blank&#34;&gt;What are move semantics in Rust?&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;Move should be handled and clarified separately. It is related to reference types.&lt;/p&gt;
&lt;h3 id=&#34;splitting-borrows-and-partial-moves&#34;&gt;Splitting borrows and partial moves&lt;/h3&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: Old proposals</title>
      <link>https://boschresearch.github.io/blech-doc/docs/language-evolution/old/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://boschresearch.github.io/blech-doc/docs/language-evolution/old/</guid>
      <description>
        
        
        &lt;h2 id=&#34;accessing-the-blech-environment&#34;&gt;Accessing the Blech environment&lt;/h2&gt;
&lt;h3 id=&#34;environment-variables&#34;&gt;Environment variables&lt;/h3&gt;
&lt;p&gt;Environment variables are either read-only inputs or read-write outputs.
Every environment variables has a counterpart in the Blech environment.
Therefore, they are annotated as &lt;code&gt;@[CInput ...]&lt;/code&gt; or &lt;code&gt;@[COutput ...]&lt;/code&gt;.
Environment variables are classified by the keyword &lt;code&gt;extern&lt;/code&gt;. 
A &lt;code&gt;extern let&lt;/code&gt; definition must be annotated with a &lt;code&gt;@[CInput ...]&lt;/code&gt;.
An &lt;code&gt;extern var&lt;/code&gt; definition must be annotated with a &lt;code&gt;@[COutput ...]&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;@[CInput (binding = &amp;quot;theSensor&amp;quot;, header = &amp;quot;sensors.h&amp;quot;)]
extern let sensor: uint8 

@[COutput (binding = &amp;quot;spiIsReady&amp;quot;, header = &amp;quot;spi.h&amp;quot;)]
extern var spiReady: bool
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Since the external C variables bound to the environment variables live in the environment they do not follow the synchronous semantics. 
They might be &lt;code&gt;volatile&lt;/code&gt; changing their value during a reaction. 
They might be read or written asynchronously by the environment.&lt;/p&gt;
&lt;p&gt;In order to synchronize these C variables, the Blech program holds a buffered value of the external value in the environment variable.&lt;/p&gt;
&lt;p&gt;The Blech runtime system takes care of the synchronisation.
Before the reaction, the values of all external C variables are copied into the environment variable.
After the reaction, the values of the &lt;code&gt;extern var&lt;/code&gt; variables are copied into the external C variables.&lt;/p&gt;
&lt;p&gt;The implementation is allowed to distribute these copying operations into the code generated for each activity, that defines &lt;code&gt;extern&lt;/code&gt; variables.&lt;/p&gt;
&lt;p&gt;Environment variables can only be declared in an &lt;code&gt;activity&lt;/code&gt;.
Functions can only access environment variables via the parameter list.&lt;/p&gt;
&lt;h3 id=&#34;external-read-write-c-variables-are-singletons&#34;&gt;External read-write C variables are singletons&lt;/h3&gt;
&lt;p&gt;An external C variable is a global variable, which is in danger to be accessed concurrently via the environment variable.
While Blech in general prevents this danger by not allowing the declaration of global variables at all, it needs more effort to guarantee this for external C variables.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;activity handleCVariables()
    
    @[CInput (binding = &amp;quot;theSensor&amp;quot;, header = &amp;quot;sensors.h&amp;quot;)]
    extern let sensor: uint8
    @[COutput (binding = &amp;quot;spiIsReady&amp;quot;, header = &amp;quot;spi.h&amp;quot;)]
    extern var spiReady: bool

    repeat
        if sensor &amp;gt; 10 then
            spiReady = true
        end
        await true
    end
end
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;In order to comply to the single-writer principle, declaring an &lt;code&gt;extern var&lt;/code&gt; variable in an activity restricts this activity to be instantiated only once.
The declared variable is a &lt;code&gt;singleton&lt;/code&gt; and does not allow multiple instances.
An activity that declares a singleton cannot be called concurrently, but only sequentially.
Note that this is only necessary for &lt;code&gt;extern var&lt;/code&gt; declarations.
An &lt;code&gt;extern let&lt;/code&gt; variable is &lt;em&gt;not&lt;/em&gt; a &lt;code&gt;singleton&lt;/code&gt;.
Different instances of such an activity can have separate buffers of the external C variable, which might have different values in the same reaction if the external C variable is &lt;code&gt;volatile&lt;/code&gt;.
It is the responsibility of the programmer not to share external C variables in different &lt;code&gt;extern var&lt;/code&gt; declarations.
Two or more &lt;code&gt;extern let&lt;/code&gt; declarations are allowed to have the same annotation &lt;code&gt;@[CInput ...]&lt;/code&gt;.&lt;/p&gt;
&lt;h3 id=&#34;singletons-and-separate-compilation&#34;&gt;Singletons and separate compilation&lt;/h3&gt;
&lt;p&gt;If a module exports an activity that contains a singleton, the signature needs to reflect this in order to enable a correct causality analysis.
The signature for the above activity &lt;code&gt;handleCVariables&lt;/code&gt; looks like the following&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;singleton handleCVariables.spiReady 
activity handleCVariables()
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;It shows the activities prototype, exposes the unique names of the singletons and shows their annotations. 
Showing the annotations allows to check the binding to C variables also for modules where the implementation is hidden.&lt;/p&gt;
&lt;h3 id=&#34;the-diamond-call-problem&#34;&gt;The diamond call problem&lt;/h3&gt;
&lt;p&gt;If an activity declares a singleton, it still can be called from several activities.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;activity firstUsage()
    run handleCVariables()
end

activity secondUsage()
    run handleCVariables()
end
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Again &lt;code&gt;firstUsage&lt;/code&gt; and &lt;code&gt;secondUsage&lt;/code&gt; can not be called concurrently.&lt;/p&gt;
&lt;p&gt;In order to check this via the signature, the calling activities, inherits the singletons from the called activity.
In a module signature these activities occur as follows&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;singleton handleCVariables.spiReady
activity firstUsage()

singleton handleCVariables.spiReady
activity secondUsage()

&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;If we combine activities with different singletons, they must not be called concurrently, if they share common singletons.
For example assume the following module signature.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;signature Module 

singleton handleOtherCVariable.theExternVar
activity handleOtherCVariable()
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;A calling activity might inherit all singletons&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;import Module

activity thirdUsage()
    cobegin
        run handleCVariables()
    with
        run handleOtherCVariable()
    end
end
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The deduced signature is&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;import Module

singleton handleCVariables.spiReady, 
          Module.handleOtherCVariable.theExternVar
activity thirdUsage()
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Activity &lt;code&gt;thirdUsage&lt;/code&gt; cannot be called concurrently to &lt;code&gt;firstUsage&lt;/code&gt; or &lt;code&gt;secondUsage&lt;/code&gt; because their singletons overlap.&lt;/p&gt;
&lt;h3 id=&#34;structured-access-to-external-variables&#34;&gt;Structured access to external variables&lt;/h3&gt;
&lt;p&gt;Environment variables can also be referenced from a &lt;code&gt;struct&lt;/code&gt; type, like normal Blech variables.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;struct MyCVariables
    var x: int32
    let ref sensor: uint8
    var ref spiReady: bool
end
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;activity referToCVariables()
    @[CInput (binding = &amp;quot;theSensor&amp;quot;, header = &amp;quot;sensors.h&amp;quot;)]
    extern let sensor: uint8 

    @[COutput (binding = &amp;quot;spiIsReady&amp;quot;, header = &amp;quot;spi.h&amp;quot;)]
    extern var spiReady: bool

    var mcvs: MyCVariables = { x = 0, sensor = sensor, spiReady = spiReady }
end
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;If we use both activities &lt;code&gt;referToCVariables&lt;/code&gt; and &lt;code&gt;handleCVariables&lt;/code&gt; in a Blech program we obviously made a mistake.
Both activities write to the same external C Variable &lt;code&gt;&amp;quot;spiIsReady&amp;quot;&lt;/code&gt;.
The single-writer principle is broken.
The semantics of the program is undefined concerning the environment access.
In general working with externals is unsafe.
In this particular case, it is the responsibility of the programmer to take care, not to share the same &lt;code&gt;COutput&lt;/code&gt; between different &lt;code&gt;extern var&lt;/code&gt; declarations.&lt;/p&gt;
&lt;p&gt;The signatures of both activities cannot reveal this error.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;singleton referToCVariables.spiReady
activity referToCVariables()

singleton handleCVariables.spiReady
activity handleCVariables()
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Idea: It should be the responsibility. of the compiler to collect the environment of a Blech program across all modules in order to allow for a code review supported by such a description file.&lt;/p&gt;
&lt;p&gt;Hints: &lt;code&gt;extern var&lt;/code&gt; and &lt;code&gt;extern let&lt;/code&gt; declarations cannot be declared inside functions.
Use &lt;code&gt;extern let&lt;/code&gt; declarations when possible in order to prevent the propagation of the singletons.&lt;/p&gt;
&lt;p&gt;Since signatures are deduced by the compiler, the whole checking of singletons and the generation of appropriate signatures is done by the compiler.&lt;/p&gt;
&lt;p&gt;Note: A conventional embedded program is full of singletons, not only created by &lt;code&gt;extern var&lt;/code&gt; declarations, but especially by global variables.
In order to maintain the single-writer principle by programming discipline it is almost inevitable, that all functions are only called once in a task list. This makes reuse and testing extremely difficult. Only the rather small number of services is reusable and rather easily testable.&lt;/p&gt;

      </description>
    </item>
    
  </channel>
</rss>
