<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Blech – The Blech language - user manual</title>
    <link>https://boschresearch.github.io/blech-doc/docs/user-manual/</link>
    <description>Recent content in The Blech language - user manual on Blech</description>
    <generator>Hugo -- gohugo.io</generator>
    
	  <atom:link href="https://boschresearch.github.io/blech-doc/docs/user-manual/index.xml" rel="self" type="application/rss+xml" />
    
    
      
        
      
    
    
    <item>
      <title>Docs: Notation</title>
      <link>https://boschresearch.github.io/blech-doc/docs/user-manual/notation/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://boschresearch.github.io/blech-doc/docs/user-manual/notation/</guid>
      <description>
        
        
        &lt;p&gt;We use a modified Backus-Naur form notation to describe the Blech language syntax.
The modifications to the original BNF make the rules look more like regular expressions.
We follow the same notation conventions as the &lt;a href=&#34;https://docs.python.org/3/reference/index.html&#34; target=&#34;_blank&#34;&gt;Python language documentation&lt;/a&gt;
. Here is what they write about notation:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The descriptions of lexical analysis and syntax use a modified BNF grammar notation. This uses the following style of definition:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-abnf&#34; data-lang=&#34;abnf&#34;&gt;&lt;span style=&#34;color:#000&#34;&gt;name&lt;/span&gt;      ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;  lc_&lt;span style=&#34;color:#000&#34;&gt;letter&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;lc_&lt;span style=&#34;color:#000&#34;&gt;letter&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;_&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;*&lt;/span&gt;
lc_&lt;span style=&#34;color:#000&#34;&gt;letter&lt;/span&gt; ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;  &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;a&amp;#34;&lt;/span&gt;...&lt;span style=&#34;color:#000&#34;&gt;&amp;#34;z&amp;#34;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The first line says that a &lt;code&gt;name&lt;/code&gt; is an &lt;code&gt;lc_letter&lt;/code&gt; followed by a sequence of zero or more &lt;code&gt;lc_letter&lt;/code&gt;s and underscores. An &lt;code&gt;lc_letter&lt;/code&gt; in turn is any of the single characters &lt;code&gt;&#39;a&#39;&lt;/code&gt; through &lt;code&gt;&#39;z&#39;&lt;/code&gt;. (This rule is actually adhered to for the names defined in lexical and grammar rules in this document.)&lt;/p&gt;
&lt;p&gt;Each rule begins with a name (which is the name defined by the rule) and &lt;code&gt;::=&lt;/code&gt;. A vertical bar (&lt;code&gt;|&lt;/code&gt;) is used to separate alternatives; it is the least binding operator in this notation. A star (&lt;code&gt;*&lt;/code&gt;) means zero or more repetitions of the preceding item; likewise, a plus (&lt;code&gt;+&lt;/code&gt;) means one or more repetitions, and a phrase enclosed in square brackets (&lt;code&gt;[ ]&lt;/code&gt;) means zero or one occurrences (in other words, the enclosed phrase is optional). The &lt;code&gt;+*+&lt;/code&gt; and &lt;code&gt;+&lt;/code&gt; operators bind as tightly as possible; parentheses are used for grouping. Literal strings are enclosed in quotes. White space is only meaningful to separate tokens. Rules are normally contained on a single line; rules with many alternatives may be formatted alternatively with each line after the first beginning with a vertical bar.&lt;/p&gt;
&lt;p&gt;In lexical definitions (as the example above), two more conventions are used: Two literal characters separated by three dots mean a choice of any single character in the given (inclusive) range of ASCII characters. A phrase between angular brackets (&lt;code&gt;+&amp;lt;...&amp;gt;+&lt;/code&gt;) gives an informal description of the symbol defined; e.g., this could be used to describe the notion of ‘control character’ if needed.&lt;/p&gt;
&lt;/blockquote&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: Lexical elements</title>
      <link>https://boschresearch.github.io/blech-doc/docs/user-manual/lexical/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://boschresearch.github.io/blech-doc/docs/user-manual/lexical/</guid>
      <description>
        
        
        &lt;h2 id=&#34;comments&#34;&gt;Comments&lt;/h2&gt;
&lt;p&gt;Single line comments are C++ style. They begin with &lt;code&gt;//&lt;/code&gt; and end with the end of line.&lt;/p&gt;
&lt;p&gt;Multi-line comments are C style. They begin with &lt;code&gt;/*&lt;/code&gt; and end with &lt;code&gt;*/&lt;/code&gt;. 
Comment nesting is supported.&lt;/p&gt;
&lt;h3 id=&#34;declaration-comments&#34;&gt;Declaration Comments&lt;/h3&gt;
&lt;p&gt;A special comment syntax allows to write comments for declarations (functions, activities, types, variables, &amp;hellip;) which will be transported over to the generated C code.
This allows to document the API and make this documentation available to the C programmer who integrates generated code in a larger scope.&lt;/p&gt;
&lt;p&gt;There are two supported styles of declaration comments.
Java style multi-line comments &lt;code&gt;/** */&lt;/code&gt; and .Net style single line comments &lt;code&gt;///&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Note that using declaration comments before something that is not a declaration, e.g. an assignment, is a syntax error.&lt;/p&gt;
&lt;h2 id=&#34;built-in-operators-and-separators&#34;&gt;Built-in Operators and Separators&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Operators and Separators&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Logical operators&lt;/td&gt;
&lt;td&gt;&lt;code&gt;not&lt;/code&gt; &lt;code&gt;and&lt;/code&gt; &lt;code&gt;or&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Arithmetic operators&lt;/td&gt;
&lt;td&gt;&lt;code&gt;+&lt;/code&gt; &lt;code&gt;-&lt;/code&gt; &lt;code&gt;*&lt;/code&gt; &lt;code&gt;/&lt;/code&gt; &lt;code&gt;%&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Bitwise operators&lt;/td&gt;
&lt;td&gt;&lt;code&gt;~&lt;/code&gt; &lt;code&gt;&amp;amp;&lt;/code&gt; &lt;code&gt;|&lt;/code&gt; &lt;code&gt;^&lt;/code&gt; &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Relational operators&lt;/td&gt;
&lt;td&gt;&lt;code&gt;==&lt;/code&gt; &lt;code&gt;!=&lt;/code&gt; &lt;code&gt;&amp;lt;&lt;/code&gt; &lt;code&gt;&amp;gt;&lt;/code&gt; &lt;code&gt;&amp;lt;=&lt;/code&gt; &lt;code&gt;&amp;gt;=&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Type conversion&lt;/td&gt;
&lt;td&gt;&lt;code&gt;as&lt;/code&gt; &lt;code&gt;as!&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Separators&lt;/td&gt;
&lt;td&gt;&lt;code&gt;(&lt;/code&gt; &lt;code&gt;)&lt;/code&gt; &lt;code&gt;[&lt;/code&gt; &lt;code&gt;]&lt;/code&gt; &lt;code&gt;{&lt;/code&gt; &lt;code&gt;}&lt;/code&gt; &lt;code&gt;.&lt;/code&gt; &lt;code&gt;,&lt;/code&gt; &lt;code&gt;;&lt;/code&gt; &lt;code&gt;:&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;keywords&#34;&gt;Keywords&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;abort&lt;/code&gt;
&lt;code&gt;activity&lt;/code&gt;
&lt;code&gt;and&lt;/code&gt;
&lt;code&gt;as&lt;/code&gt; 
&lt;code&gt;await&lt;/code&gt;
&lt;code&gt;bits8&lt;/code&gt;
&lt;code&gt;bits16&lt;/code&gt; 
&lt;code&gt;bits32&lt;/code&gt;
&lt;code&gt;bits64&lt;/code&gt;
&lt;code&gt;blech&lt;/code&gt;
&lt;code&gt;bool&lt;/code&gt;
&lt;code&gt;cobegin&lt;/code&gt;
&lt;code&gt;const&lt;/code&gt;
&lt;code&gt;do&lt;/code&gt;
&lt;code&gt;else&lt;/code&gt;
&lt;code&gt;elseif&lt;/code&gt;
&lt;code&gt;end&lt;/code&gt;
&lt;code&gt;extern&lt;/code&gt;
&lt;code&gt;false&lt;/code&gt;
&lt;code&gt;float32&lt;/code&gt;
&lt;code&gt;float64&lt;/code&gt;
&lt;code&gt;function&lt;/code&gt;
&lt;code&gt;if&lt;/code&gt;
&lt;code&gt;int8&lt;/code&gt;
&lt;code&gt;int16&lt;/code&gt;
&lt;code&gt;int32&lt;/code&gt;
&lt;code&gt;int64&lt;/code&gt;
&lt;code&gt;let&lt;/code&gt;
&lt;code&gt;nat8&lt;/code&gt;
&lt;code&gt;nat16&lt;/code&gt;
&lt;code&gt;nat32&lt;/code&gt;
&lt;code&gt;nat64&lt;/code&gt;
&lt;code&gt;not&lt;/code&gt;
&lt;code&gt;or&lt;/code&gt;
&lt;code&gt;param&lt;/code&gt;
&lt;code&gt;prev&lt;/code&gt;
&lt;code&gt;repeat&lt;/code&gt;
&lt;code&gt;run&lt;/code&gt;
&lt;code&gt;reset&lt;/code&gt;
&lt;code&gt;return&lt;/code&gt;
&lt;code&gt;returns&lt;/code&gt;
&lt;code&gt;singleton&lt;/code&gt;
&lt;code&gt;struct&lt;/code&gt;
&lt;code&gt;then&lt;/code&gt;
&lt;code&gt;true&lt;/code&gt;
&lt;code&gt;until&lt;/code&gt;
&lt;code&gt;var&lt;/code&gt;
&lt;code&gt;weak&lt;/code&gt;
&lt;code&gt;when&lt;/code&gt;
&lt;code&gt;while&lt;/code&gt;
&lt;code&gt;with&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Note that the current compiler implementation may reserve more keywords than listed here.
This is because the language is still growing and there are concepts that are yet to be fully implemented but already exist on the syntactical level.&lt;/p&gt;
&lt;h2 id=&#34;identifiers&#34;&gt;Identifiers&lt;/h2&gt;
&lt;p&gt;An identifier is any token that is not a keyword and starts with a letter or underscore and continues with an arbitrary number of letters, digits or underscores.
The precise definition is given by the following grammar rule&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-abnf&#34; data-lang=&#34;abnf&#34;&gt;&lt;span style=&#34;color:#000&#34;&gt;Identifier&lt;/span&gt; ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;  &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;_&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;&amp;#34;a&amp;#34;&lt;/span&gt;...&lt;span style=&#34;color:#000&#34;&gt;&amp;#34;z&amp;#34;&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;A&amp;#34;&lt;/span&gt;...&lt;span style=&#34;color:#000&#34;&gt;&amp;#34;Z&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;+ &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;&amp;#34;_&amp;#34;&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;a&amp;#34;&lt;/span&gt;...&lt;span style=&#34;color:#000&#34;&gt;&amp;#34;z&amp;#34;&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;A&amp;#34;&lt;/span&gt;...&lt;span style=&#34;color:#000&#34;&gt;&amp;#34;Z&amp;#34;&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;0&amp;#34;&lt;/span&gt;...&lt;span style=&#34;color:#000&#34;&gt;&amp;#34;9&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;*&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Note that identifiers have an infix of at least one letter.&lt;/p&gt;
&lt;h2 id=&#34;wildcard&#34;&gt;Wildcard&lt;/h2&gt;
&lt;p&gt;Additionally we reserve a token that consists of underscores only.
We call this the &amp;ldquo;wildcard&amp;rdquo;. Wildcards are useful when you want to discard the result of a computation without declaring a dummy variable.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;_ = f()
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;In this example you cannot just call &lt;code&gt;f&lt;/code&gt; like in C because the Blech compiler will complain that &lt;code&gt;f&lt;/code&gt; is declared to return a value but there is no location to store this value in. The wildcard makes the intention to discard the returned value &lt;em&gt;explicit&lt;/em&gt;.&lt;/p&gt;
&lt;h2 id=&#34;literals&#34;&gt;Literals&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-abnf&#34; data-lang=&#34;abnf&#34;&gt;&lt;span style=&#34;color:#000&#34;&gt;BoolLiteral&lt;/span&gt; ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;true&amp;#34;&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;false&amp;#34;&lt;/span&gt;

&lt;span style=&#34;color:#000&#34;&gt;Digit&lt;/span&gt;        ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;0&amp;#34;&lt;/span&gt;...&lt;span style=&#34;color:#000&#34;&gt;&amp;#34;9&amp;#34;&lt;/span&gt;
&lt;span style=&#34;color:#000&#34;&gt;NonZeroDigit&lt;/span&gt; ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;1&amp;#34;&lt;/span&gt;...&lt;span style=&#34;color:#000&#34;&gt;&amp;#34;9&amp;#34;&lt;/span&gt;

&lt;span style=&#34;color:#000&#34;&gt;BinInteger&lt;/span&gt; ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;0b&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;&amp;#34;_&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;0&amp;#34;&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;1&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;+
&lt;span style=&#34;color:#000&#34;&gt;OctInteger&lt;/span&gt; ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;0o&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;&amp;#34;_&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;0&amp;#34;&lt;/span&gt;...&lt;span style=&#34;color:#000&#34;&gt;&amp;#34;7&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;+
&lt;span style=&#34;color:#000&#34;&gt;HexInteger&lt;/span&gt; ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;0x&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;&amp;#34;_&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;0&amp;#34;&lt;/span&gt;...&lt;span style=&#34;color:#000&#34;&gt;&amp;#34;7&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;&amp;#34;_&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;Digit&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;a&amp;#34;&lt;/span&gt;...&lt;span style=&#34;color:#000&#34;&gt;&amp;#34;f&amp;#34;&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;A&amp;#34;&lt;/span&gt;...&lt;span style=&#34;color:#000&#34;&gt;&amp;#34;F&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;+  
&lt;span style=&#34;color:#000&#34;&gt;DecInteger&lt;/span&gt; ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;NonZeroDigit&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;([&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;&amp;#34;_&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Digit&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;*&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;0&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;([&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;&amp;#34;_&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;0&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;*&lt;/span&gt;

&lt;span style=&#34;color:#000&#34;&gt;Integer&lt;/span&gt; ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;DecInteger&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;BinInteger&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;OctInteger&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;HexInteger&lt;/span&gt;

&lt;span style=&#34;color:#000&#34;&gt;FloatNumber&lt;/span&gt;   ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;  &lt;span style=&#34;color:#000&#34;&gt;PointFloat&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;ExponentFloat&lt;/span&gt;
&lt;span style=&#34;color:#000&#34;&gt;PointFloat&lt;/span&gt;    ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;  &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;DigitPart&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Fraction&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;DigitPart&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;.&amp;#34;&lt;/span&gt;
&lt;span style=&#34;color:#000&#34;&gt;DigitPart&lt;/span&gt;     ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;  &lt;span style=&#34;color:#000&#34;&gt;Digit&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;([&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;&amp;#34;_&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Digit&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;*&lt;/span&gt;
&lt;span style=&#34;color:#000&#34;&gt;Fraction&lt;/span&gt;      ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;  &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;.&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;DigitPart&lt;/span&gt;
&lt;span style=&#34;color:#000&#34;&gt;ExponentFloat&lt;/span&gt; ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;  &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;DigitPart&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;PointFloat&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;exponent&lt;/span&gt;
&lt;span style=&#34;color:#000&#34;&gt;Exponent&lt;/span&gt;      ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;  &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;&amp;#34;e&amp;#34;&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;E&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;&amp;#34;+&amp;#34;&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;-&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;DigitPart&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
      </description>
    </item>
    
    <item>
      <title>Docs: Control flow</title>
      <link>https://boschresearch.github.io/blech-doc/docs/user-manual/controlflow/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://boschresearch.github.io/blech-doc/docs/user-manual/controlflow/</guid>
      <description>
        
        
        
      </description>
    </item>
    
    <item>
      <title>Docs: Declarations</title>
      <link>https://boschresearch.github.io/blech-doc/docs/user-manual/declarations/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://boschresearch.github.io/blech-doc/docs/user-manual/declarations/</guid>
      <description>
        
        
        &lt;p&gt;Declarations introduce new names for entities in the program.
Declarable entities include&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;activities&lt;/li&gt;
&lt;li&gt;functions&lt;/li&gt;
&lt;li&gt;types&lt;/li&gt;
&lt;li&gt;data storage&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In the future more of such entities may be added to the language such as clocks and physical units.&lt;/p&gt;
&lt;p&gt;Every declaration exists in a &lt;em&gt;lexical scope&lt;/em&gt;.
Scopes define the visibility of a name.
The top-level or file scope is the most global scope in Blech.
Functions, activities and types are defined here.
Entities in the top-level scope are visible everywhere in the file.
Every block introduces a sub-scope.
For example, a function body is a local scope.
Variables defined in this scope are visible in this function but not outside of it.
Composite statements, such as the &lt;code&gt;repeat&lt;/code&gt; loop introduce their statement-local scope. This allows to introduce a variable that is visible during the iteration through this loop and not outside of it.&lt;/p&gt;


&lt;div class=&#34;alert alert-primary&#34; role=&#34;alert&#34;&gt;

Once we implement a module system for Blech, the mechanisms for controlling visibility will need to be elaborated in more detail.
&lt;/div&gt;

&lt;p&gt;In Blech, declarations not only introduce a name but also &lt;em&gt;define&lt;/em&gt; what this name represents. For example, a function declaration will specify a function body.
That is the block of statements that are executed when this functions is called.
The definition may refer to names that were previously declared.&lt;/p&gt;


&lt;div class=&#34;alert alert-warning&#34; role=&#34;alert&#34;&gt;

Declare before use! Even if, for example, functions are defined on the same scope, a function can only call other functions that have been declared before.
&lt;/div&gt;

&lt;p&gt;In the following we discuss the various entities that can be defined in a Blech program.&lt;/p&gt;
&lt;h2 id=&#34;data&#34;&gt;Data&lt;/h2&gt;
&lt;p&gt;Data declarations consist of an access and placement qualifier, an identifier, a data type and an initialisation.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-abnf&#34; data-lang=&#34;abnf&#34;&gt;&lt;span style=&#34;color:#000&#34;&gt;DataDeclaration&lt;/span&gt; ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Qualifier&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Identifier&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;:&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Type&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;=&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Init&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;A variable declaration:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;var x: int32 = 17
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The type is either a built-in type or a name of a user defined type.
Built-in types are discussed in the next chapter.
Type declarations are discussed in the next section.&lt;/p&gt;
&lt;p&gt;Initialisers are expressions that evaluate to a value that matches this declaration&amp;rsquo;s data type. Expressions (including literals) will be discussed in a later chapter.&lt;/p&gt;
&lt;h3 id=&#34;qualifiers&#34;&gt;Qualifiers&lt;/h3&gt;
&lt;p&gt;There are four possible qualifiers.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-abnf&#34; data-lang=&#34;abnf&#34;&gt;&lt;span style=&#34;color:#000&#34;&gt;Qualifier&lt;/span&gt; ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;const&amp;#34;&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;param&amp;#34;&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;let&amp;#34;&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;var&amp;#34;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;const&lt;/code&gt; qualified data is relevant for the compilation phase only and does not have any representation in memory at run time. 
Typical use cases for &lt;code&gt;const&lt;/code&gt; are sizes of data structures, addresses in memory, &amp;hellip; 
In C, these are represented by &lt;code&gt;#define&lt;/code&gt; macros, which, too, have no representation after the preprocessor finishes.
Hence &lt;em&gt;using const on arrays (or structs containing arrays), albeit possible, is not advisable&lt;/em&gt; and produces inefficient code because temporary variables have to be created (and filled) at runtime for every (non-constant) access to these arrays.
Instead consider &lt;code&gt;param&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;param&lt;/code&gt; qualified data has a representation in memory at run time but cannot be changed by the running program for its entire lifetime (it can only be reflashed).
Typical use cases for &lt;code&gt;param&lt;/code&gt; are characteristics maps or other immutable lookup data structures.
The name &amp;ldquo;param&amp;rdquo; indicates that such data is a parameter of the final compilation result.
Tools exist to customise such parameters in a binary file directly in order to adapt the given software to a variant of a product.
Like with &lt;code&gt;const&lt;/code&gt; data, the &lt;code&gt;param&lt;/code&gt; value must be initialised with constant expressions.
You cannot write the following&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;function f (input: int32)
   param x: int32 = input // error!
end
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This is because the value of &lt;code&gt;input&lt;/code&gt; is determined at &lt;em&gt;runtime&lt;/em&gt; but &lt;code&gt;x&lt;/code&gt; must be initialised at &lt;em&gt;compile time&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;const&lt;/code&gt; and &lt;code&gt;param&lt;/code&gt; data may be declared at top level as well as inside functions or activities.
The other two qualifiers &lt;code&gt;let&lt;/code&gt; and &lt;code&gt;var&lt;/code&gt; indicate local data and may &lt;em&gt;only&lt;/em&gt; be used inside functions or activities.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;let&lt;/code&gt; declares immutable data in the control flow of a program.
Finally, &amp;lsquo;var&amp;rsquo; declares the usual mutable variable.
Initialisation may be omitted for mutable variables. In this case the Blech compiler will automatically initialise the variable with its type&amp;rsquo;s default value.
The type annotation may be omitted if the type can be unambiguously determined from the initialisation expression.&lt;/p&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;const LEN: int32 = 8
param lut: [LEN]float64 = {1.0, 0.5, 0.25, 0.125} // LEN is constant and may be used here
                                                  // the array literal will be filled with additional 0&#39;s up to length LEN.
function f()
    let i = LEN - 7 // i is deduced to be int32
    var x = lut[i] // x is deduced to be float64
                   // and equals 0.5 in this case
end
&lt;/code&gt;&lt;/pre&gt;

&lt;div class=&#34;alert alert-info&#34; role=&#34;alert&#34;&gt;

No global variables in Blech!
We deliberately prohibit the use of &lt;code&gt;let&lt;/code&gt; and &lt;code&gt;var&lt;/code&gt; outside subprogram scopes because we believe this leads to better understandable, easier to integrate and unit-testable programs.
&lt;/div&gt;



&lt;div class=&#34;alert alert-warning&#34; role=&#34;alert&#34;&gt;

Confusion may arise about the difference between &lt;code&gt;param&lt;/code&gt; and &lt;code&gt;let&lt;/code&gt;.
They both qualify immutable data in memory.
They could be even stored in the same way which however is a compiler implementation detail and none of the concerns of the programmer.
The crucial difference is that &lt;code&gt;let&lt;/code&gt; takes values at runtime.
It is immutable throughout the scope where it has been declared.
Once the scope is left and re-entered, the value of that &lt;code&gt;let&lt;/code&gt; variable may be re-initialised. (In the literature this is sometimes dramatically referred to as &amp;ldquo;re-incarnation&amp;rdquo;.)
As stated above, &lt;code&gt;param&lt;/code&gt; data cannot be changed by the running program at all, it is completely static.
&lt;/div&gt;



&lt;div class=&#34;alert alert-warning&#34; role=&#34;alert&#34;&gt;

The word &amp;ldquo;parameter&amp;rdquo; appears in two notions. One is the &amp;ldquo;formal parameter&amp;rdquo; of a function or activity.
The other is the &amp;ldquo;param&amp;rdquo; qualifier for immutable data.
The first parametrises a function (ar activity), the second parametrises a whole binary.
We try to make clear which one we mean throughout this document. Usually it should be apparent from context however.
&lt;/div&gt;

&lt;h2 id=&#34;user-defined-types&#34;&gt;User defined types&lt;/h2&gt;
&lt;p&gt;The programmer may define a data structure using the &lt;code&gt;struct&lt;/code&gt; keyword.


&lt;div class=&#34;alert alert-primary&#34; role=&#34;alert&#34;&gt;
&lt;h4 class=&#34;alert-heading&#34;&gt;TODO&lt;/h4&gt;
See the chapter on &lt;a href=&#34;https://boschresearch.github.io/blech-doc/docs/user-manual/types/#structure-types&#34;&gt;struct types&lt;/a&gt; for more details.
&lt;/div&gt;
&lt;/p&gt;
&lt;h2 id=&#34;subprograms&#34;&gt;Subprograms&lt;/h2&gt;
&lt;p&gt;Blech discerns two type of subprograms: &lt;code&gt;activity&lt;/code&gt; and &lt;code&gt;function&lt;/code&gt;.
Their behaviour is different. Activities must pause at least once whereas functions need to terminate within one reaction. Functions are therefore called &amp;ldquo;instantaneous&amp;rdquo;.
The precise differences will be worked out in the chapter on Blech statements.
From a syntactic declaration point of view there is hardly any difference.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-abnf&#34; data-lang=&#34;abnf&#34;&gt;&lt;span style=&#34;color:#000&#34;&gt;ProgramDeclaration&lt;/span&gt; ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;&amp;#34;singleton&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;ProgramType&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Identifier&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;ParamList&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;ParamList&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;&amp;#34;returns&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Type&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;StmtBlock&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;end&amp;#34;&lt;/span&gt;
&lt;span style=&#34;color:#000&#34;&gt;ProgramType&lt;/span&gt;        ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;function&amp;#34;&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;activity&amp;#34;&lt;/span&gt;
&lt;span style=&#34;color:#000&#34;&gt;ParamList&lt;/span&gt;          ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;()&amp;#34;&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;(&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;ParamDeclaration&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;&amp;#34;,&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;ParamDeclaration&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;)&amp;#34;&lt;/span&gt;
&lt;span style=&#34;color:#000&#34;&gt;ParamDeclaration&lt;/span&gt;   ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Identifier&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;:&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Type&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;There are two parameter lists. 
The first lists declares formal parameters that may only be read (like &lt;code&gt;let&lt;/code&gt; variables), the second list declares formal parameters that may be both read and written (like &lt;code&gt;var&lt;/code&gt; variables).
In particular the two lists are useful for activities which, in every reaction, receive a list of read-only &lt;em&gt;inputs&lt;/em&gt;, perform some calculation and set the list of read-write &lt;em&gt;outputs&lt;/em&gt;.
We will therefore often refer to these two parameter lists as &amp;ldquo;input list&amp;rdquo; and &amp;ldquo;output list&amp;rdquo;.&lt;/p&gt;
&lt;p&gt;The programming model is that all variables are passed by reference (even though in reality the compiler will optimise this into by-value for simple value typed inputs).&lt;/p&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;function add (x: int32, y: int32) returns int32
   return x + y
end

@[EntryPoint]
activity A (in: int32)(out: int32)
   repeat
      out = add(in, out)
      await true
   end
end
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The example above is a valid Blech program that sums all inputs over all time steps.
Note that &lt;code&gt;add&lt;/code&gt; omits an output list and &lt;code&gt;A&lt;/code&gt; does not declare any return type.
We call functions or activities that do not return anything &amp;ldquo;void&amp;rdquo; but unlike C we do not have a void type in the language.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;@[EntryPoint]&lt;/code&gt; annotation tells the compiler that &lt;code&gt;A&lt;/code&gt; is the main program of this file. Every Blech file must have precisely one entry point activity.
&lt;em&gt;(That is until we have a module system that allows to write libraries that may have no single entry point at all).&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;singleton&lt;/code&gt; keyword is optional and may be used to indicate that there may exist only one instance of this subprogram in a concurrent context. 
For example, this is useful to indicate early on in the development phase that an activity will have some interaction with the external environment.
The caller of a singleton callee automatically becomes a singleton, too.&lt;/p&gt;
&lt;h2 id=&#34;external-declarations&#34;&gt;External Declarations&lt;/h2&gt;
&lt;p&gt;Sometimes it is useful to access global variables or functions of a C program.
This allows for example to make use of existing libraries.
Such variables and functions are &lt;em&gt;external&lt;/em&gt; from the point of view of a Blech program.
Annotations are required to tell the compiler how to code-generate access to these external entities.&lt;/p&gt;
&lt;p&gt;Formally, we have the following syntax.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-abnf&#34; data-lang=&#34;abnf&#34;&gt;&lt;span style=&#34;color:#000&#34;&gt;ExternFunctionDeclaration&lt;/span&gt; ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;extern&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;&amp;#34;singleton&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;function&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Identifier&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;ParamList&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;ParamList&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;returns&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Type&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;]&lt;/span&gt;
&lt;span style=&#34;color:#000&#34;&gt;ExternDataDeclaration&lt;/span&gt;     ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;extern&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Qualifier&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Identifier&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;:&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Type&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Obviously, external functions have no body and external variables cannot be initialised.
As before, external functions may be characterised as &lt;code&gt;singleton&lt;/code&gt; which means such a function may not be called concurrently. This is useful when the external function to be called is not a pure function because it either returns a volatile value or has some effect on the environment. Calling such a function concurrently would violate the synchrony assumptions and lead to unexpected results.&lt;/p&gt;
&lt;p&gt;External declarations additionally require annotations which we introduce by example below.&lt;/p&gt;
&lt;p&gt;[IMPORTANT]
Note that the type-safety and causality guarantees of Blech vanish once you interact with an external C implementation. That means the Blech compiler relies on the assumption that the specified annotations and interfaces are correct. We&amp;rsquo;ll point out a few caveats below.&lt;/p&gt;
&lt;h3 id=&#34;external-constants&#34;&gt;External constants&lt;/h3&gt;
&lt;p&gt;In C, constant values may be defined using macros or &lt;code&gt;const&lt;/code&gt; variables.
In order to make these values available in Blech, external constants may be declared.
External constant declarations may appear in any scope.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;@[CConst (binding = &amp;quot;PI&amp;quot;, header = &amp;quot;math.h&amp;quot;)]
extern const pi: float64
@[CParam (binding = &amp;quot;characteristics&amp;quot;, header = &amp;quot;magic.h&amp;quot;)]
extern param map: [10]float32
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Both Blech qualifiers &lt;code&gt;const&lt;/code&gt; and &lt;code&gt;param&lt;/code&gt; are supported.
They require a &lt;code&gt;CConst&lt;/code&gt; or a &lt;code&gt;CParam&lt;/code&gt; annotation respectively.
However they have more of a documentation character rather than any functional difference.
Both will evaluate whatever expression is given in the binding at runtime.
This is the reason why external constants cannot be used for constant expression evaluation in Blech &amp;ndash; their value is unknown at compile time.
While you can, for example, use a Blech constant to parametrise an array length, you cannot do so using an external constant.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;binding&lt;/code&gt; annotation attribute may contain any expression that can be evaluated in C.&lt;/p&gt;
&lt;p&gt;By design the Blech compiler generates C code that links with other C code but at no point in time does the Blech compiler &amp;ldquo;look into&amp;rdquo; C header or implementation files, nor does it try to evaluate any C-bindings.&lt;/p&gt;
&lt;h3 id=&#34;local-external-variables&#34;&gt;Local external variables&lt;/h3&gt;
&lt;p&gt;The aforementioned constants may be declared in local scopes as well.
Additionally, local Blech variables that link to external global variables may be declared inside activities (but not in functions).&lt;/p&gt;
&lt;p&gt;[NOTE]
There is no semantical reason why external variables cannot be declared inside functions. It is simply due to compiler implementation pragmatics that we exclude this possibility as of now.&lt;/p&gt;
&lt;p&gt;Access to external variables is useful to keep interfaces slim. That is you do not need to pass all data into the entry point activity and down the call chain to the piece of code that actually needs this data and then propagate the results back up this chain to the entry point to communicate the updated values to the environment.
These variables follow the same rules as the usual activity-local variables.&lt;/p&gt;
&lt;p&gt;Read-only external variables are annotated with the &lt;code&gt;CInput&lt;/code&gt; annotation.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;@[CInput (binding = &amp;quot;PIN_7&amp;quot;, header = &amp;quot;head.h&amp;quot;)]
extern let isButtonPressed: bool
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This example assumes there is either a C macro or a C variable &lt;code&gt;PIN_7&lt;/code&gt; that returns a volatile boolean value indicating a button press.&lt;/p&gt;
&lt;p&gt;The declaration creates a local variable inside the enclosing activity.
It serves as a copy-in buffer.
When the activity starts a reaction the value of &lt;code&gt;PIN_7&lt;/code&gt; is copied into &lt;code&gt;isButtonPressed&lt;/code&gt;.
Within the Blech program we can only access the buffer &lt;code&gt;isButtonPressed&lt;/code&gt; and thereby have the guarantee that the value does not change during one reaction.
This corresponds to the semantics of activity input parameters.&lt;/p&gt;
&lt;p&gt;An activity that declares an immutable external variable does not become a singleton.
Concurrent instances may exist but they may contain different values for the same external variable if it is volatile.&lt;/p&gt;
&lt;p&gt;Read-write external variables are annotated with the &lt;code&gt;COutput&lt;/code&gt; annotation.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;@[COutput (binding = &amp;quot;PIN_7&amp;quot;, header = &amp;quot;head.h&amp;quot;)]
extern var isButtonPressed: bool
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Here at the beginning of a reaction the value of &lt;code&gt;PIN_7&lt;/code&gt; is copied in.
During a reaction the variable &lt;code&gt;isButtonPressed&lt;/code&gt; can be modified as usual.
At the end of the reaction the value of &lt;code&gt;isButtonPressed&lt;/code&gt; is copied out to &lt;code&gt;PIN_7&lt;/code&gt;.
This guarantees a stable output behaviour. Intermediate changes to the local variable &lt;code&gt;isButtonPressed&lt;/code&gt; are not observable by the environment.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;prev&lt;/code&gt; operator may be used on external variables.
It returns the value that the variable held at the end of the previous reaction.
This behaviour corresponds to using &lt;code&gt;prev&lt;/code&gt; on normal local variables but there is a subtle difference.
External variables may be changed by the environment.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;@[COutput (binding = &amp;quot;PIN_7&amp;quot;, header = &amp;quot;head.h&amp;quot;)]
extern var isButtonPressed: bool
isButtonPressed = true
await cond // some boolean condition
var x = prev isButtonPressed // is x == true?
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;If &lt;code&gt;cond&lt;/code&gt; is true immediately in the next reaction then x will be set to &lt;code&gt;true&lt;/code&gt;.
In general, however we do not know how many reaction it will take until &lt;code&gt;cond&lt;/code&gt; becomes true.
Yet in every reaction the copy-in and copy-out mechanisms will update the &lt;code&gt;isButtonPressed&lt;/code&gt; buffer.
If the environment does not change &lt;code&gt;PIN_7&lt;/code&gt; then surely &lt;code&gt;x&lt;/code&gt; will be &lt;code&gt;true&lt;/code&gt;.
But, in general, we cannot assume this.&lt;/p&gt;
&lt;p&gt;An activity that declares a mutable external variable automatically becomes a singleton.
Concurrent instances lead to a write-write conflict and compilation is rejected.&lt;/p&gt;
&lt;h3 id=&#34;external-functions&#34;&gt;External functions&lt;/h3&gt;
&lt;p&gt;There are two ways to link to external functions in Blech.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Via direct binding to function name declared in an .h file&lt;/li&gt;
&lt;li&gt;Via a wrapper to be implemented in some .c file.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;In the first case we annotate the name of the C function and the file wherein this function is declared.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;@[CFunction (binding = &amp;quot;ceil&amp;quot;, header = &amp;quot;math.h&amp;quot;)]
extern function ceiling(i: float64) returns float64
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Inside the Blech program this function is now available through name &lt;code&gt;ceiling&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;In the second case we annotate which file we intend to implement the C function in.
Actually this information is irrelevant for the Blech compilation itself.
However, it may become useful in the future once a build system can make sense of these annotations and automatically detect which files are required for the compilation of the whole project.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;extern function myCFunction(i: float64) returns float64
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Assume the above declaration is written in a Blech file called &lt;code&gt;MyFile.blc&lt;/code&gt;, then the code generator will produce a header file &lt;code&gt;MyFile.h&lt;/code&gt; with the following code:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;// extern functions to be implemented in C
&lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;blc_float64&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;blc_MyFile_myCFunction&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;blc_float64&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;blc_i&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;It is up to the C programmer now to include this header in his implementation and provide an actual definition of this function.&lt;/p&gt;
&lt;h3 id=&#34;remarks-on-caveats-when-interfacing-with-c&#34;&gt;Remarks on caveats when interfacing with C&lt;/h3&gt;
&lt;h4 id=&#34;types&#34;&gt;Types&lt;/h4&gt;
&lt;p&gt;Blech has no representation of C types. It requires that the C implementation matches the Blech types. This is usually straightforward for simple types. If there is no one-to-one correspondence between types a wrapper has to be implemented in C that marshals the data between Blech and the actual C function to be called.&lt;/p&gt;
&lt;h4 id=&#34;parameter-lists&#34;&gt;Parameter lists&lt;/h4&gt;
&lt;p&gt;In Blech, functions have two parameter lists as explained above. 
The Blech compiler ensures that inputs will only be read. 
However the Blech compiler has no chance to check that the external code adheres to this contract.&lt;/p&gt;
&lt;p&gt;For example, say we have an external function that takes an array of length 10 and sorts it in-place.
The correct binding would look something like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;@[CFunction (binding = &amp;quot;sort&amp;quot;, header = &amp;quot;utils.h&amp;quot;)]
extern function sort()(arr: [10]int32)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;In this way, the Blech compiler knows that &lt;code&gt;sort&lt;/code&gt; will modify the given array. When calling this function in a concurrent context the compiler will prevent write-write conflicts and read-write cycles on the array.&lt;/p&gt;
&lt;p&gt;However, the programmer could erroneously declare the same function as follows:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;@[CFunction (binding = &amp;quot;sort&amp;quot;, header = &amp;quot;utils.h&amp;quot;)]
extern function sort(arr: [10]int32)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The code will compile all the same but the causality guarantees are gone because the Blech compiler relies on the assumption that the array will only be read and not modified. At runtime the program may then exhibit unexpected behaviour.&lt;/p&gt;
&lt;h4 id=&#34;singletons&#34;&gt;Singletons&lt;/h4&gt;
&lt;p&gt;The &lt;code&gt;singleton&lt;/code&gt; annotation is a help to the Blech programmer but does not completely prevent concurrent calls to functions with conflicting effects. For example:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;@[CFunction (binding = &amp;quot;foo&amp;quot;, header = &amp;quot;head.h&amp;quot;)]
extern singleton function doA() 
@[CFunction (binding = &amp;quot;foo&amp;quot;, header = &amp;quot;head.h&amp;quot;)]
extern singleton function doB() 

/* ... somewhere in an acitivity scope ... */
cobegin
   doA()
with
   doB()
end
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This example is a valid Blech program because two different singleton functions are called. This is allowed. However the annotation points to the same C function which is obviously a problem. While a linter could in principle check for this &lt;em&gt;particular&lt;/em&gt; mistake there are many more possibilities to specify bindings to functions which will have conflicting effects when called concurrently.
It is up to the programmer to know what are the effects of the external functions to be called and to avoid scenarios such as the one above.&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: Types</title>
      <link>https://boschresearch.github.io/blech-doc/docs/user-manual/types/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://boschresearch.github.io/blech-doc/docs/user-manual/types/</guid>
      <description>
        
        
        &lt;p&gt;A &lt;em&gt;type&lt;/em&gt; defines a &lt;em&gt;domain&lt;/em&gt; &amp;ndash; a set of &lt;em&gt;values&lt;/em&gt; &amp;ndash; a &lt;em&gt;representation&lt;/em&gt; for those values and a set of &lt;em&gt;operations&lt;/em&gt; on those values.&lt;/p&gt;
&lt;p&gt;Often the domains overlap between types.
Also operations may be overloaded for multiple types.
This provides the programmer with some versatility:&lt;/p&gt;
&lt;p&gt;For example, signed integers and unsigned integers share some interval in which calculations may be carried out and interpreted as either one.
Another example is that operations such as addition may have different implementations depending on type (and machine architecture): addition of 16-bit unsigned integers on a 16-bit machine invokes a different set of machine instructions than addition of 32-bit unsigned integers on that same machine.
Yet the same symbol &lt;code&gt;+&lt;/code&gt; denotes both computations in program text.
The same operator also covers additions of numbers for a completely different domain such as floats.&lt;/p&gt;
&lt;p&gt;This versatility comes at a price: the programmer has to pay attention to value ranges, make representation changes explicit and make sure that a unique implementation of an operation (such as &lt;code&gt;+&lt;/code&gt;) can be selected by the compiler.&lt;/p&gt;
&lt;p&gt;Blech is a type safe language which assists the programmer with a powerful type checker that prevents most type related errors at compile time.
It enforces type annotations and explicit casts whenever the type of an expression is not obvious or when a representation needs to be changed before the expression fits the context of an operation.&lt;/p&gt;
&lt;p&gt;The following sections precisely describe which types exist, what their domains and representations are, which operations they define and which types may be combined or transformed into one another.&lt;/p&gt;
&lt;h2 id=&#34;boolean-type&#34;&gt;Boolean type&lt;/h2&gt;
&lt;p&gt;Blech distinguishes a &lt;code&gt;bool&lt;/code&gt; type with two values: &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt;.
Boolean values may be combined using the binary &lt;code&gt;and&lt;/code&gt; and &lt;code&gt;or&lt;/code&gt; operators.
A boolean value is inverted by the unary &lt;code&gt;not&lt;/code&gt; operator.
All comparisons are admissible.
Expressions which evaluate to a boolean value are called &lt;em&gt;conditions&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;In Blech, it is required that conditions that determine the control flow must be side-effect free.
For example, the statements &lt;code&gt;await&lt;/code&gt;, &lt;code&gt;abort&lt;/code&gt;, &lt;code&gt;reset&lt;/code&gt;, &lt;code&gt;repeat..until&lt;/code&gt;, &lt;code&gt;while&lt;/code&gt;, &lt;code&gt;if&lt;/code&gt; all require side-effect free conditions.
The reason is that the evaluation of a condition should not change the program&amp;rsquo;s state.
It would contradict the synchronous semantics if a program&amp;rsquo;s state changed although no reaction was performed in case an &lt;code&gt;await&lt;/code&gt; condition evaluated to &lt;code&gt;false&lt;/code&gt;.
The same reasoning applies to other synchronous control flow statements such as &lt;code&gt;abort&lt;/code&gt; and &lt;code&gt;reset&lt;/code&gt;.
Other imperative control flow statements such as loops or the &lt;code&gt;if&lt;/code&gt; statement follow the same logic for consistency and clarity of the program text.&lt;/p&gt;
&lt;h2 id=&#34;integer-types&#34;&gt;Integer types&lt;/h2&gt;
&lt;p&gt;Integer types are divided into three categories: natural numbers, signed integer numbers and &amp;ldquo;bits&amp;rdquo;.
Each one exist in four sizes that indicate the number of bits needed in a machine to represent a value of this type: 8, 16, 32, 64.&lt;/p&gt;
&lt;p&gt;.Integer types
[cols=&amp;quot;2*&amp;quot;,grid=rows]
|===
| &lt;code&gt;nat8&lt;/code&gt;, &lt;code&gt;nat16&lt;/code&gt;, &lt;code&gt;nat32&lt;/code&gt;, &lt;code&gt;nat64&lt;/code&gt; | Natural numbers
| &lt;code&gt;int8&lt;/code&gt;, &lt;code&gt;int16&lt;/code&gt;, &lt;code&gt;int32&lt;/code&gt;, &lt;code&gt;int64&lt;/code&gt; | Signed integer numbers
| &lt;code&gt;bits8&lt;/code&gt;, &lt;code&gt;bits16&lt;/code&gt;, &lt;code&gt;bits32&lt;/code&gt;, &lt;code&gt;bits64&lt;/code&gt; | Bits
|===&lt;/p&gt;
&lt;p&gt;The distinction of three integral types has the following motivation.
As usual, we would like to distinguish non-negative numbers of the length &lt;code&gt;N&lt;/code&gt; with a range of &lt;code&gt;0&lt;/code&gt; to &lt;code&gt;2^N -1&lt;/code&gt; from integer numbers centred around 0 with a range of &lt;code&gt;2^(N-1)&lt;/code&gt; to &lt;code&gt;2^(N-1) -1&lt;/code&gt;.
However, by design, the operations on both kinds of numbers prohibit overflows.Computations must stay within the representable domain. 
Depending on the build mode an overflow causes the program to crash or to mitigate it using saturation arithmetic.
In order to allow writing algorithms that do rely on overflowing non-negative integers as in C, as well as bit-masking and bit-shifting the &lt;code&gt;bitsX&lt;/code&gt; type is introduced.
The bits type of length &lt;code&gt;N&lt;/code&gt; have the same value range as the natural numbers of the same length.&lt;/p&gt;
&lt;p&gt;It is possible to cast between all three types without information loss so long as the size remains unchanged.&lt;/p&gt;
&lt;p&gt;All integral types types admit all arithmetic and comparison operators.
The &lt;code&gt;bitsX&lt;/code&gt; types additionally admit bitwise operations.&lt;/p&gt;
&lt;h2 id=&#34;floating-point-types&#34;&gt;Floating-point types&lt;/h2&gt;
&lt;p&gt;Blech provides the two most commonly used floating point types &lt;code&gt;float32&lt;/code&gt; and &lt;code&gt;float64&lt;/code&gt;.
The language assumes an implementation of these according to IEEE standards.
In the generated code they are mapped to C&amp;rsquo;s &lt;code&gt;float&lt;/code&gt; and &lt;code&gt;double&lt;/code&gt; respectively (see section on &amp;laquo;types:blechconf,blechconf.h&amp;raquo; below).&lt;/p&gt;
&lt;p&gt;Note that the C standard does not guarantee an IEEE compliant implementation of its floating point types nor does it require that &lt;code&gt;float&lt;/code&gt; and &lt;code&gt;double&lt;/code&gt; are distinct types at all.
It is the system integrators responsibility to ensure that the C compiler at hand does fulfil Blech&amp;rsquo;s assumptions.&lt;/p&gt;
&lt;p&gt;Floating point types admit all arithmetic and comparison operators.&lt;/p&gt;
&lt;h2 id=&#34;array-types&#34;&gt;Array types&lt;/h2&gt;
&lt;p&gt;The array data type is parametrised by a fixed &amp;ldquo;shape&amp;rdquo; and a payload data type.
The shape of an array is its dimensionality and length in each dimension.
It is not possible to declare an array data type with an unspecified length.&lt;/p&gt;
&lt;h3 id=&#34;arrays&#34;&gt;Arrays&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;function f(a: [4][5]float32)
    /* ... */
end
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The function &lt;code&gt;f&lt;/code&gt; expects one read-only argument &lt;code&gt;a&lt;/code&gt;.
It is two dimensional array (a table) with 4 rows and 5 columns.
Each cell contains a &lt;code&gt;float32&lt;/code&gt; number.&lt;/p&gt;
&lt;p&gt;Unlike C, in Blech the lengths appear before the payload type in the type declaration.&lt;/p&gt;
&lt;p&gt;Elements of an array are accessed using a subscription operation &lt;code&gt;[]&lt;/code&gt;.
The first element has index &lt;code&gt;0&lt;/code&gt;.
If an array dimension has &lt;code&gt;N&lt;/code&gt; values, the last index is &lt;code&gt;N-1&lt;/code&gt;.
The index argument must be an integer number within array bounds.&lt;/p&gt;
&lt;p&gt;The contents of one array may be copied to another using assignment provided their shape and payload data type are the same.&lt;/p&gt;
&lt;h3 id=&#34;array-operations&#34;&gt;Array operations&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;// Initialise the following matrix
//      cols
// rows 0.0  0.0
//      1.2  3.4
//      0.0  0.0
var a: [3][2]float32 = {[1]={1.2, 3.4}}

let r: [2]float32 = a[1] // copy 2nd row of a into r

let x = a[1][1]          // copy 3.4 to x
                         // x is deduced to have type float32
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;structure-types&#34;&gt;Structure types&lt;/h2&gt;
&lt;p&gt;Structure declarations introduce a new type identifier.
A structure contains a fixed number of &lt;em&gt;fields&lt;/em&gt;.
Each field has an access capability (&lt;code&gt;let&lt;/code&gt; or &lt;code&gt;var&lt;/code&gt;), a name, some data type and possibly a default value initialiser.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-abnf&#34; data-lang=&#34;abnf&#34;&gt;&lt;span style=&#34;color:#000&#34;&gt;StructDeclaration&lt;/span&gt; ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;struct&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Identifier&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Field&lt;/span&gt;+ &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;end&amp;#34;&lt;/span&gt;
&lt;span style=&#34;color:#000&#34;&gt;Field&lt;/span&gt;            ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;&amp;#34;var&amp;#34;&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;let&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Identifier&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;:&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Type&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;&amp;#34;=&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;If an initialiser is given for a field this value is taken as the default value when constructing an instance of this structure.
The initialisation expression must be a compile time value.
Of course, this default value may be overruled by the initialiser given at the instantiation.&lt;/p&gt;
&lt;h3 id=&#34;mutable-and-immutable-structures&#34;&gt;Mutable and immutable structures&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;struct S
   var a: int32 = 7
   var b: int32
end

/* ... somewhere in a local scope ... */
var s1: S    // s1 == {a = 7, b = 0}
s1.b = 17    // ok, now s1 == {a = 7, b = 17}
s1.a = 42    // ok, now s1 == {a = 42, b = 17}
s1 = {}      // ok, reset to default, now s1 == {a = 7, b = 0}

let s2: S = {a = -10, b = 10} // s2 == {a = -10, b = 10}
s2.b = 17                     // error! Cannot change the let variable s2
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Structure &lt;code&gt;s1&lt;/code&gt; is declared using a &lt;code&gt;var&lt;/code&gt; access qualifier.
The fields may be overwritten as well as the structure as a whole.
By contrast, &lt;code&gt;s2&lt;/code&gt; is declared using &lt;code&gt;let&lt;/code&gt;.
It cannot be changed after initialisation.&lt;/p&gt;
&lt;p&gt;The above example illustrates all operations available on structures.
The dot &lt;code&gt;.&lt;/code&gt; is used to access a field value inside a structure.
If the value of a field again is a structure it may be further &amp;ldquo;dotted into&amp;rdquo;.
Structures may be assigned using a struct literal or a name of another struct of the same data type.
Assigning the empty literal &lt;code&gt;{}&lt;/code&gt; means that all default values are restored.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;let&lt;/code&gt; fields cannot be changed once the structure is instantiated.
Assignment on structures as a whole is only permitted if all (sub-)field have &lt;code&gt;var&lt;/code&gt; access qualifiers (and the struct itself has been declared using &lt;code&gt;var&lt;/code&gt;).&lt;/p&gt;
&lt;h3 id=&#34;immutable-fields-in-structures&#34;&gt;Immutable fields in structures&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;struct T
    let a: int32
    var b: int32
end

struct S
    var x: T
    var y: int32
end

/* usage in local scope */
var s: S = {x.a = 7} // ok, s == {x = {a = 7, b = 0}, y = 0}
s.x.b = 42           // ok, s == {x = {a = 7, b = 42}, y = 0}
s = {}               // error! s contains immutable fields
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Assignments to the struct &lt;code&gt;s&lt;/code&gt; are prohibited because &lt;code&gt;s.x.a&lt;/code&gt; is immutable.
You need to individually specify which fields you want to update.
It may be helpful to implement a helper function for this specific data type as shown below.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;function resetS()(s: S)
    s.x.b = 0
    s.y = 0
end

/* usage in local scope */
var s: S
/* ... */
resetS()(s)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;[[types:blechconf]]&lt;/p&gt;
&lt;h2 id=&#34;blechconfh&#34;&gt;blechconf.h&lt;/h2&gt;
&lt;p&gt;Blech compiles to C.
Hence code generation has to map Blech types to C types.
The file &lt;code&gt;blechconf.h&lt;/code&gt; specifies this mapping.
It is automatically included (via &lt;code&gt;blech.h&lt;/code&gt;) in every generated C source file.
The Blech compiler guarantees type safety and correct operational behaviour so long as Blech types are mapped onto C types that fit above representation sizes.
It is up to the system integrator to ensure that this mapping is valid for the C compiler and hardware platform at hand.&lt;/p&gt;
&lt;p&gt;A default mapping that makes sense in most cases is shipped with the compiler:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;#define BLC_VOID void 
&lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;#define BLC_BOOL int 
&lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;#define BLC_INT8 signed char
&lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;#define BLC_INT16 signed short
&lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;#define BLC_INT32 signed long
&lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;#define BLC_INT64 signed long long
&lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;#define BLC_UINT8 unsigned char
&lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;#define BLC_UINT16 unsigned short
&lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;#define BLC_UINT32 unsigned long
&lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;#define BLC_UINT64 unsigned long long
&lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;#define BLC_BITS8 unsigned char
&lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;#define BLC_BITS16 unsigned short
&lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;#define BLC_BITS32 unsigned long
&lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;#define BLC_BITS64 unsigned long long
&lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;#define BLC_FLOAT32 float
&lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;#define BLC_FLOAT64 double
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;However compilers before the C99 standard may not support &lt;code&gt;unsigned long long&lt;/code&gt;, for example.&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: Expressions</title>
      <link>https://boschresearch.github.io/blech-doc/docs/user-manual/expressions/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://boschresearch.github.io/blech-doc/docs/user-manual/expressions/</guid>
      <description>
        
        
        &lt;p&gt;The nomenclature in Blech is similar to that in C.
There are typed memory locations (objects), left hand side expressions (lvalues) and right hand side expressions (rvalues).
Blech does allow to create function references and thus we have no designators.&lt;/p&gt;
&lt;h2 id=&#34;operator-precedence&#34;&gt;Operator precedence&lt;/h2&gt;
&lt;p&gt;The expression grammar below will not specify the precedence of operators.
This allows for a concise presentation.
Therefore this section specifies the precedence separately.&lt;/p&gt;
&lt;p&gt;All operators are left associative in Blech.
The following table summarizes the operator precedence in Blech, from lowest precedence (least binding) to highest precedence (most binding). Operators in the same box have the same precedence. Unless the syntax is explicitly given, operators are binary.&lt;/p&gt;
&lt;p&gt;Operator precedence low to high:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Operators&lt;/th&gt;
&lt;th&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;:&lt;/code&gt;, &lt;code&gt;as&lt;/code&gt;, &lt;code&gt;as!&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Type annotation and type cast&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;or&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Boolean disjunction&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;and&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Boolean conjunction&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;=&lt;/code&gt;, &lt;code&gt;==&lt;/code&gt;, &lt;code&gt;!=&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Comparisons&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;|&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Bitwise OR&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;^&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Bitwise XOR&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;amp;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Bitwise AND&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;lt;&amp;gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;&amp;lt;&amp;gt;&lt;/code&gt;, &lt;code&gt;+&amp;gt;&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Shifts, rotations and signed right shift&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Addition and subtraction&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;*&lt;/code&gt;, &lt;code&gt;/&lt;/code&gt;, &lt;code&gt;+&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Multiplication, division and remainder&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;not&lt;/code&gt; x, &lt;code&gt;-&lt;/code&gt;x, &lt;code&gt;~&lt;/code&gt;x&lt;/td&gt;
&lt;td&gt;Negation, unary minus, bit inversion&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;atoms&#34;&gt;Atoms&lt;/h2&gt;
&lt;p&gt;Atoms are the building blocks of expressions.
They are composed using operators.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-abnf&#34; data-lang=&#34;abnf&#34;&gt;&lt;span style=&#34;color:#000&#34;&gt;Atom&lt;/span&gt; ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Identifier&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;Literal&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;{}&amp;#34;&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;ArrayLiteral&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;StructLiteral&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;ParenthForm&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Note that the term &amp;ldquo;atom&amp;rdquo; is not to be taken too literally because array and structure literals may contain arbitrary expressions themselves.&lt;/p&gt;
&lt;h3 id=&#34;identifiers&#34;&gt;Identifiers&lt;/h3&gt;
&lt;p&gt;An identifier occurring as an atom is a name. See section Identifiers and keywords for lexical definition.&lt;/p&gt;
&lt;h3 id=&#34;literals&#34;&gt;Literals&lt;/h3&gt;
&lt;p&gt;Blech supports various numeric literals:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-abnf&#34; data-lang=&#34;abnf&#34;&gt;&lt;span style=&#34;color:#000&#34;&gt;Literal&lt;/span&gt; ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;BoolLiteral&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;Integer&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;FloatNumber&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Evaluation of a literal yields an object of the given type (bytes, natural number, signed integer, floating point number) with the given value.
The value may be approximated in the case of floating point literals.&lt;/p&gt;
&lt;p&gt;Numeric literals are untyped on their own.
This makes their use more flexible and permits writing more generic code.
Of course, before code generation every expression (and thus every literal) must be assigned a type which is the task of the type checker.
This section explains how to use literals and what type errors may happen.&lt;/p&gt;
&lt;p&gt;Literals are assigned a type either explicitly using a &lt;em&gt;type annotation&lt;/em&gt; expression or implicitly when a unique type can be deduced from the context.&lt;/p&gt;
&lt;h4 id=&#34;annotated-literals&#34;&gt;Annotated literals&lt;/h4&gt;
&lt;p&gt;For example, the literal &lt;code&gt;1&lt;/code&gt; could represent a natural number, a signed integer or a byte word of some size. It could even be a floating point number.
It can be explicitly annotated using a type annotation.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;1: nat16    // 2 bytes long natural number
1: int8     // 1 byte signed integer
1: bits32   // 4 bytes long word
1: float32  // single precision floating point number
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;====&lt;/p&gt;
&lt;p&gt;The lexical analysis of &lt;code&gt;Literal&lt;/code&gt; above suggests there are three kinds of literals.
In fact, we distinguish two kinds of integers.
Binary, octal and hexadecimal integer literals form the group of &lt;em&gt;bits literals&lt;/em&gt;.
They may be interpreted as a byte word of some length or as a natural number of some length.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;0xFF: nat32    // 4 byte natural number with value 255
0b101: bit8    // 1 byte word with value 5
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;They cannot be treated as a signed integer because depending on the length and the machine&amp;rsquo;s representation of negative numbers they might yield a negative or positive value.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;0xFF: int8    // error! Would be -1 if represented in two&#39;s complement
0xFF: int16   // error! Would be 255 in a two byte word
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Also, bits literals cannot be interpreted as floating point numbers.
For the exact specification of floating point numbers a hexadecimal float literal will be introduced.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Decimal integers&lt;/em&gt; may be interpreted as any kind of numeric type as long as the value fits the domain. The example above shows the straightforward use case with the literal &lt;code&gt;1&lt;/code&gt;. Below some corner cases are exemplified:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;-2: nat16     // error! Outside range of natural numbers
-200: int8    // error! Outside range [-128..127]
-2: bits8     // 1 byte word with value 254
-200: float32 // single precision floating point number
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Float literals may only be interpreted as either single or double precision floating point numbers even if their fraction part is zero as in &lt;code&gt;10.0&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;In summary: annotations may only be used where they do not change the value of the expression and the value fits into the domain of the type.&lt;/p&gt;
&lt;h4 id=&#34;type-deduction-for-literals&#34;&gt;Type deduction for literals&lt;/h4&gt;
&lt;p&gt;When a literal occurs as part of a binary expression where one side is already fully typed, the literal&amp;rsquo;s type may be automatically deduced.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;
&lt;table style=&#34;border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;&#34;&gt;&lt;tr&gt;&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;&#34;&gt;
&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;1
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;;width:100%&#34;&gt;
&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-txt&#34; data-lang=&#34;txt&#34;&gt;var a: int32 = 9
let b = a + 17    
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;In line 1, the 9 is deduced to have type &lt;code&gt;int32&lt;/code&gt; because the left hand side is already typed.
Note that a bits literal cannot be used to initialise an integer for reasons explained &amp;laquo;expr:bitsliterals,above&amp;raquo;.&lt;/p&gt;
&lt;p&gt;In line 2, the literal &lt;code&gt;17&lt;/code&gt; is deduced to be &lt;code&gt;int32&lt;/code&gt;, then a signed 32-bit addition is performed and &lt;code&gt;b&lt;/code&gt; is also deduced to be an &lt;code&gt;int32&lt;/code&gt;.&lt;/p&gt;
&lt;h3 id=&#34;complex-literals&#34;&gt;Complex literals&lt;/h3&gt;
&lt;h4 id=&#34;reset-literal&#34;&gt;Reset literal&lt;/h4&gt;
&lt;p&gt;Empty braces &lt;code&gt;{}&lt;/code&gt; have a special meaning.
They represent the default value for any struct or literal.
Using the reset literal in a declaration has the same effect as leaving out the initialisation:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;var x: [8]float32 = {}
var y: [8]float32
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Both &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; will be initialised with zeros in all cells.
The reset literal, as the name suggests, is most useful to set a modified data structure back to its default values:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;var x: [8]float32 = {1, 2, 3, 4, 5, 6, 7, 8}
x = {}    // now x == {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The reset literal cannot be assigned to a structure that contains immutable fields (or, recursively, substructures with immutable fields).
The same is true for arrays with struct payloads.
See the section on &amp;laquo;types:struct,struct types&amp;raquo; for more details.&lt;/p&gt;
&lt;h4 id=&#34;array-literals&#34;&gt;Array literals&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-abnf&#34; data-lang=&#34;abnf&#34;&gt;&lt;span style=&#34;color:#000&#34;&gt;ArrayLiteral&lt;/span&gt; ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;{&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;CellInit&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;&amp;#34;,&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;CellInit&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;}&amp;#34;&lt;/span&gt;
&lt;span style=&#34;color:#000&#34;&gt;CellInit&lt;/span&gt;     ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;IndexExpr&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;=&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt;
&lt;span style=&#34;color:#000&#34;&gt;IndexExpr&lt;/span&gt;    ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;[&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;]&amp;#34;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The array literal has to fit the shape of the array it is assigned to.
That is, the &lt;code&gt;Expr&lt;/code&gt; in &lt;code&gt;IndexExpr&lt;/code&gt; must evaluate to a non-negative number within array bounds.
It is however permitted to specify fewer values than the number given by the array dimensions.
The missing values are implicitly set to the data type&amp;rsquo;s default value.
It is possible to set specific array cells by also specifying an index for a value.
Subsequent unindexed values will be set for the next array cells in order.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;Expr&lt;/code&gt; in &lt;code&gt;CellInit&lt;/code&gt; must match the array&amp;rsquo;s data type.&lt;/p&gt;
&lt;h5 id=&#34;example-setting-array-values&#34;&gt;Example: Setting array values&lt;/h5&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;var x: [2][3]nat8 = {{1, 2, 3},{4, 5, 6}} // all explicit
// x is
// 1  2  3
// 4  5  6

x[1] = {7, 8}                             // third value implicitly 0
// x is
// 1  2  3
// 7  8  0

x[1] = {[1] = 9, 10}                      // first value implicitly 0
// x is                                   // the index of `10` implicitly is 2
// 1  2  3
// 0  9  10

x = {{[1] = 11},{[0] = 12, [2] = 13}}
// x is
// 0  11  0
// 12  0  13

x = { {[2]=14} }                          // second row implicitly zeroed out
// x is
// 0  0  14
// 0  0  0
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;struct-literals&#34;&gt;Struct literals&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-abnf&#34; data-lang=&#34;abnf&#34;&gt;&lt;span style=&#34;color:#000&#34;&gt;StructLiteral&lt;/span&gt; ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;{&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;FieldInit&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;&amp;#34;,&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;FieldInit&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;}&amp;#34;&lt;/span&gt;
&lt;span style=&#34;color:#000&#34;&gt;FieldInit&lt;/span&gt;     ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Identifier&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;=&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The identifiers must match the field names of the struct to be assigned.
The &lt;code&gt;Expr&lt;/code&gt; must match the corresponding field&amp;rsquo;s data type.
Immutable (&lt;code&gt;let&lt;/code&gt; declared) fields may only be set in the initialisation of the structure.
Fields that are not specified in the literal are implicitly set to their data type&amp;rsquo;s default value.&lt;/p&gt;
&lt;h5 id=&#34;example-setting-struct-values&#34;&gt;Example: Setting struct values&lt;/h5&gt;
&lt;p&gt;Assume the following declarations:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;struct S
    var a: int8
    var b: int8
end

struct T
    let x: bool
    var y: S
end
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The following code may be written (in some local scope):&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;var t: T = {x = true, y = {a = 1, b = 2}}
// t is
// t.x == true
// t.y.a == 1
// t.y.b == 2

t = {y = {a = 7}} // error! Cannot assign immutable field t.x

t.y = {a = 7}     // implicitly b = 0
// t is
// t.x == true
// t.y.a == 7
// t.y.b == 0
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;parenthesised-form&#34;&gt;Parenthesised form&lt;/h2&gt;
&lt;p&gt;A parenthesised form is an expression enclosed in parentheses:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-abnf&#34; data-lang=&#34;abnf&#34;&gt;&lt;span style=&#34;color:#000&#34;&gt;ParenthForm&lt;/span&gt; ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;  &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;(&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;)&amp;#34;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;A parenthesised expression yields whatever that expression yields.&lt;/p&gt;
&lt;h2 id=&#34;primaries&#34;&gt;Primaries&lt;/h2&gt;
&lt;p&gt;Primaries represent the most tightly bound operations of the language. Their syntax is:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-abnf&#34; data-lang=&#34;abnf&#34;&gt;&lt;span style=&#34;color:#000&#34;&gt;Primary&lt;/span&gt; ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;  &lt;span style=&#34;color:#000&#34;&gt;Atom&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;Selection&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;Subscription&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;FunctionCallExpr&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;field-selection&#34;&gt;Field selection&lt;/h2&gt;
&lt;p&gt;A field selection is a primary expression followed by a period and a name:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-abnf&#34; data-lang=&#34;abnf&#34;&gt;&lt;span style=&#34;color:#000&#34;&gt;Selection&lt;/span&gt; ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;  &lt;span style=&#34;color:#000&#34;&gt;Primary&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;.&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Identifier&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;Primary&lt;/code&gt; must evaluate to a struct instance that contains a field with the name given by &lt;code&gt;Identifier&lt;/code&gt;.&lt;/p&gt;
&lt;h2 id=&#34;subscriptions&#34;&gt;Subscriptions&lt;/h2&gt;
&lt;p&gt;A subscripting expression selects an item of an array:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-abnf&#34; data-lang=&#34;abnf&#34;&gt;&lt;span style=&#34;color:#000&#34;&gt;Subscription&lt;/span&gt; ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;  &lt;span style=&#34;color:#000&#34;&gt;Primary&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;[&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Expression&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;]&amp;#34;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The index expression must return a value that is non-negative an smaller than the array length.
Otherwise the program will crash in debug build mode and saturate to array index bounds in release mode.&lt;/p&gt;
&lt;p&gt;[IMPORTANT]
The current implementation relies on C semantics and has no build modes. It will not necessarily crash, since C may read any addressable memory.&lt;/p&gt;
&lt;h2 id=&#34;calls&#34;&gt;Calls&lt;/h2&gt;
&lt;p&gt;A call calls a function with a possibly empty series of arguments:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-abnf&#34; data-lang=&#34;abnf&#34;&gt;&lt;span style=&#34;color:#000&#34;&gt;FunctionCallExpr&lt;/span&gt; ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Identifier&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;RhsArgList&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;LhsArgList&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;[IMPORTANT]
TODO: Currently the Rhs/LhsArgLists are defined in controlflow.adoc. Restructure?!&lt;/p&gt;
&lt;h2 id=&#34;all-computation-expressions&#34;&gt;All computation expressions&lt;/h2&gt;
&lt;p&gt;All expressions above are concerned with retrieving a single value from some data structure. (With the exception of function calls).
Now all expressions are presented which take a value (or two) and produce a new value from it (those).
The following rule gives an overview of the remaining expression syntax.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-abnf&#34; data-lang=&#34;abnf&#34;&gt;&lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt; ::&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;
    &lt;span style=&#34;color:#000&#34;&gt;Primary&lt;/span&gt;                                            &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;highest&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;precedence&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt; 
    | &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;-&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;~&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;not&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt;
    | &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;*&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;/&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;%&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt;
    | &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;+&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;-&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt;
    | &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;&amp;gt;&amp;gt;&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;&amp;lt;&amp;lt;&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;&amp;lt;&amp;gt;&amp;gt;&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;&amp;lt;&amp;lt;&amp;gt;&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;+&amp;gt;&amp;gt;&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt;
    | &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;&amp;amp;&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt;
    | &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;^&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt;
    | &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;|&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt;
    | &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;&amp;lt;&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;&amp;gt;&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;&amp;lt;=&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;&amp;gt;=&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;==&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;!=&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt;
    | &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;and&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt;
    | &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;or&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt;
    | &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;:&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Type&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;as&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Type&lt;/span&gt; | &lt;span style=&#34;color:#000&#34;&gt;Expr&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;as!&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Type&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;lowest&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;precedence&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Operator precedence has been discussed &amp;laquo;expr:precedence,above&amp;raquo;.&lt;/p&gt;
&lt;h3 id=&#34;unary-operations&#34;&gt;Unary operations&lt;/h3&gt;
&lt;p&gt;The unary &lt;code&gt;-&lt;/code&gt; (minus) operator yields the negation of its numeric argument.
If the argument is a literal without an annotation, it may not be a binary, octal or hexadecimal number because these are supposed to be some &lt;code&gt;bitX&lt;/code&gt; type without a known length (yet) and the result of a minus cannot be defined.&lt;/p&gt;
&lt;p&gt;The unary &lt;code&gt;~&lt;/code&gt; (invert) operator yields the bitwise inversion of its &lt;code&gt;bitsX&lt;/code&gt; argument.
It cannot be applied to a literal without a type annotation.&lt;/p&gt;
&lt;p&gt;The unary &lt;code&gt;not&lt;/code&gt; operator yields the opposite of its Boolean argument.&lt;/p&gt;
&lt;h3 id=&#34;binary-arithmetic-operations&#34;&gt;Binary arithmetic operations&lt;/h3&gt;
&lt;p&gt;The binary arithmetic operations require that the arguments are of some numeric type.&lt;/p&gt;
&lt;p&gt;The arithmetic operations work as expected on all arithmetic types.
See the sections on &amp;laquo;types:arithmetic,arithmetic types&amp;raquo; for details regarding overflow handling.&lt;/p&gt;
&lt;p&gt;The arguments&amp;rsquo; types may differ only in size.
When they differ, the smaller size value is lifted implicitly to the larger size.
The operation is then carried out on (possibly lifted) arguments of the same type.&lt;/p&gt;
&lt;h4 id=&#34;lifting-types&#34;&gt;Lifting types&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;var x: int8 = 7
var y: int16 = 300
var z = x + y
var u = x + 1
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are both signed integers but have different sizes.
In the context of the addition in line 3, the smaller type is lifted to the larger, effectively making &lt;code&gt;x&lt;/code&gt; an &lt;code&gt;int16&lt;/code&gt;.
Then, 16-bit signed addition is carried out producing an &lt;code&gt;int16&lt;/code&gt; typed result.
This result is stored into &lt;code&gt;z&lt;/code&gt; making it a &lt;code&gt;int16&lt;/code&gt; variable, too.&lt;/p&gt;
&lt;p&gt;In line 4, the literal &lt;code&gt;1&lt;/code&gt; is deduced to be of type &lt;code&gt;int8&lt;/code&gt; in the context of this expression (cf. paragraph on &amp;laquo;expr:deduction,type deduction&amp;raquo; for literals).
Then, 8-bit signed addition is carried out producing an &lt;code&gt;int8&lt;/code&gt; typed result.
This result is stored into &lt;code&gt;u&lt;/code&gt; making it a &lt;code&gt;int8&lt;/code&gt; variable, too.&lt;/p&gt;
&lt;p&gt;The following snippet shows typical caveats.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;
&lt;table style=&#34;border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;&#34;&gt;&lt;tr&gt;&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;&#34;&gt;
&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;1
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;2
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;3
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;4
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;5
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;6
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;7
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;;width:100%&#34;&gt;
&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-txt&#34; data-lang=&#34;txt&#34;&gt;var x: int32 = 49 - 7    // error! Cannot determine type of &amp;#39;49&amp;#39; and &amp;#39;7&amp;#39;

var y: int8 = (49: int8) - 128 // error 128 does not fit into int8

var a: bits8 = 0x1
var b: nat8 = 2
var c = a + b            // error! Type mismatch
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;In line 1, the context of &lt;code&gt;49&lt;/code&gt; is &lt;code&gt;7&lt;/code&gt; and vice versa.
Both do not have a concrete type.
It is therefore not clear which implementation of &lt;code&gt;-&lt;/code&gt; should be invoked.
The code only specifies that the result will be stored in an &lt;code&gt;int32&lt;/code&gt; memory location but several different types (&lt;code&gt;int8&lt;/code&gt;, &lt;code&gt;int16&lt;/code&gt;, &lt;code&gt;int32&lt;/code&gt;) would fit in there.&lt;/p&gt;
&lt;p&gt;In line 3, the previous issue was resolved by specifying that &lt;code&gt;49&lt;/code&gt; should be treated as an &lt;code&gt;int8&lt;/code&gt;.
Thus the other operand must be an &lt;code&gt;int8&lt;/code&gt; as well but the given literal is outside the &lt;code&gt;int8&lt;/code&gt; domain.
(In this particular case, writing &lt;code&gt;(49: int8) + (-128)&lt;/code&gt; would solve the problem due to the asymmetry of signed integers.)&lt;/p&gt;
&lt;p&gt;The last line shows on operation on different types (of the same size).
Addition for natural numbers must not overflow while addition for bits will wrap around.
It is not clear which one should be used here.
Either &lt;code&gt;a&lt;/code&gt; or &lt;code&gt;b&lt;/code&gt; need to be explicitly cast using the &lt;code&gt;as&lt;/code&gt; operator to resolve this issue.&lt;/p&gt;
&lt;h3 id=&#34;bitwise-operations&#34;&gt;Bitwise operations&lt;/h3&gt;
&lt;p&gt;// TODO&lt;/p&gt;
&lt;h3 id=&#34;comparison-operations&#34;&gt;Comparison operations&lt;/h3&gt;
&lt;p&gt;Unlike C, in Blech equality and inequality have the same priority as the ordering operators.
Furthermore the precedence of comparison operators is lower than that of any arithmetic, shifting or bitwise operation.&lt;/p&gt;
&lt;p&gt;Note that all operators are left associative.
Hence chaining comparisons is possible syntactically but makes little sense.&lt;/p&gt;
&lt;h4 id=&#34;comparison-chaining&#34;&gt;Comparison chaining&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;var b = 4 &amp;lt; 5 &amp;lt;= false // evaluates to true &amp;lt;= false which is false
var c = 4 &amp;lt; 5 &amp;lt;= 6 // type error: cannot compare true &amp;lt;= 6
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This is different to C because in Blech booleans and numbers are incomparable.&lt;/p&gt;
&lt;h4 id=&#34;comparison-lifting&#34;&gt;Comparison lifting&lt;/h4&gt;
&lt;p&gt;Comparison operators lift their arguments to a common sized type like arithmetic operators do (see above).
Additionally, comparisons permit using literals that would require a larger domain.
This allows writing (in)equalities without cluttering the code with trivial type casts.&lt;/p&gt;
&lt;h5 id=&#34;example-comparison-with-literals-outside-the-domain&#34;&gt;Example: Comparison with literals outside the domain&lt;/h5&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;var x: int8 = 7
var y = x &amp;lt; 1000
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The literal &lt;code&gt;1000&lt;/code&gt; is a (signed) integral number and would fit into an &lt;code&gt;int16&lt;/code&gt;.
Therefore we allow to implicitly lift &lt;code&gt;x&lt;/code&gt; to &lt;code&gt;int16&lt;/code&gt; and carry out the comparison.
This makes sense because the result of all comparison operators is always a Boolean value.
There are no &amp;ldquo;surprises&amp;rdquo; about the outcome.&lt;/p&gt;
&lt;h3 id=&#34;logical-operatorions&#34;&gt;Logical operatorions&lt;/h3&gt;
&lt;p&gt;The operators &lt;code&gt;and&lt;/code&gt; and &lt;code&gt;or&lt;/code&gt; may only be applied to Boolean typed arguments.&lt;/p&gt;
&lt;p&gt;The expression &lt;code&gt;a and b&lt;/code&gt; is true if and only if &lt;code&gt;a&lt;/code&gt; is true and &lt;code&gt;b&lt;/code&gt; is true.
The evaluation is performed lazily: first &lt;code&gt;a&lt;/code&gt; is evaluated. If it is false, the expression returns &lt;code&gt;false&lt;/code&gt; without evaluating &lt;code&gt;b&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The expression &lt;code&gt;a or b&lt;/code&gt; is true unless both &lt;code&gt;a&lt;/code&gt; is false and &lt;code&gt;b&lt;/code&gt; is false.
The evaluation is performed lazily: first &lt;code&gt;a&lt;/code&gt; is evaluated. If it is true, the expression returns &lt;code&gt;true&lt;/code&gt; without evaluating &lt;code&gt;b&lt;/code&gt;.&lt;/p&gt;
&lt;h3 id=&#34;representation-annotation-and-change&#34;&gt;Representation annotation and change&lt;/h3&gt;
&lt;p&gt;Type annotations specify a concrete type for a literal which may represent values from different types.&lt;/p&gt;
&lt;p&gt;Type casts &lt;em&gt;change&lt;/em&gt; the type of an already typed expression.
Casts are only permitted where the (machine) representation of a value will not change and casts assume that the value fits into the target type&amp;rsquo;s domain.&lt;/p&gt;
&lt;h4 id=&#34;safe-casts&#34;&gt;Safe casts&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-blech&#34; data-lang=&#34;blech&#34;&gt;var x: int16 = 100
let y = x as nat8    // ok, y == 100 of type nat8

x = x * 3
let z = x as nat8    // runtime error: 300 outside nat8 domain 0..255

x = -256             // assuming 2&#39;s complement on the machine:
                     // x == 0xb_1111_1111_0000_0000
let u = x as bits8   // runtime error
let v = x as bits16  // ok, v == 65280

let f: float32 = 1
x = f as int16       // error! impossible to cast floating point to integral types
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The restrictions on the casts do not rule out runtime errors.
At the same time they prevent some manipulations that are possible in C.
For example, it is not possible to interpret a floating point as a bits type and change individual bits.&lt;/p&gt;
&lt;p&gt;// TODO is the description of &lt;code&gt;as&lt;/code&gt; correct? Are there restrictions, bugs, features?&lt;/p&gt;
&lt;h3 id=&#34;evaluation-order&#34;&gt;Evaluation order&lt;/h3&gt;
&lt;p&gt;Undefined at the moment. Evaluated by the C compiler.&lt;/p&gt;

      </description>
    </item>
    
  </channel>
</rss>
